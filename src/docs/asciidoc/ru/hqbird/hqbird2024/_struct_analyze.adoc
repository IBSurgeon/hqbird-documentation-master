[[_hqbird_struct_analyze]]
= Анализ структуры базы данных

== Обзор структуры базы данных Firebird

Первое, что следует сказать о структуре базы данных Firebird, это то, что она представляет собой набор страниц строго определенного размера: 4096, 8192, 16384 или 32768 (начиная с Firebird 4.0).

Страницы могут быть разных типов, каждая из которых служит определенной цели.

Страницы одного типа не идут строго одна за другой -- они могут быть перемешаны, и размещены в файле в том порядке, в котором они были созданы сервером при расширении или создании базы данных.

image::5.1.1.png[]

.Типы страниц
[cols="1,1,1", options="header"]
|===
| Тип страницы
| ID
| Описание

|**pag_undefined**
|0
|Undefined - Если страница имеет этот тип страницы, скорее всего, она пуста.

|**pag_header**
|1
|Database header page

|**pag_pages**
|2
|Page inventory page (or Space inventory page – SIP)

|**pag_transactions**
|3
|Transaction inventory page (TIP)

|**pag_pointer**
|4
|Pointer page

|**pag_data**
|5
|Data page

|**pag_root**
|6
|Index root page

|**pag_index**
|7
|Index (B-tree) page

|**pag_blob**
|8
|Blob data page

|**pag_ids**
|9
|Gen-ids

|**pag_log**
|10
|Write ahead log information
|===

<<<

== Как анализировать структуру базы данных с помощью HQbird Database Analyst (IBAnalyst)

*IBAnalyst* — это инструмент, который помогает пользователю детально анализировать статистику базы данных Firebird и выявлять возможные проблемы с производительностью базы данных, ее обслуживанием и взаимодействием приложения с базой данных.

IBAnalyst графически отображает статистику базы данных Firebird в удобной для пользователя форме и выявляет следующие проблемы:

* фрагментирование таблиц и BLOB,
* версии записей,
* сборка мусора,
* эффективность индексов

Более того, IBAnalyst может автоматически вносить разумные предложения по улучшению производительности и обслуживанию базы данных.

IBAnalyst может получать статистику из действующих производственных баз данных через Services API (рекомендуется) или анализировать текстовый вывод команд `gstat -a -r ...`.
Статистика в периоды пиковой нагрузки может дать много информации о реальных проблемах с производительностью в производственных базах данных.

Основные возможности IBAnalyst перечислены ниже:

* Получение статистики базы данных через Service API и из вывода `gstat`.
* Сводка всех актуальных и возможных проблем в базе данных
* Цветная сетка для представления таблиц, индексов и таблиц->индексов, которая выделяет фрагментированные таблицы, плохие индексы и т. д.
* Автоматическая экспертиза статистики базы данных предоставляет рекомендации и инструкции по следующим вопросам:
** Оптимальный размер страницы базы данных
** Состояние транзакций и критический разрыв между транзакциями.
** Различные флаги базы данных
** Глубина индекса
** Дубликаты ключей индекса
** Фрагментированные таблицы
** Версии записи
** Очень большие таблицы
* и другое

=== Как правильно получать статистику из базы данных Firebird

==== Правильное время и место

Звучит странно, но просто взять статистику через gstat или Services API недостаточно. Статистику необходимо собирать в нужный момент, чтобы показать, как приложения влияют на данные и транзакции в базе данных.

Худшее время для сбора статистики

* Сразу после восстановления
* После снятия резервной копии (`gbak –b db.gdb`) без указания переключателя `–g`
* После ручного sweep (`gfix –sweep`)

Также верно, что во время работы могут быть моменты, когда база данных находится в правильном состоянии, например, когда приложения нагружают базу данных меньше, чем обычно (пользователи обедают, ужинают или в определенное время бизнес-процесса).

Как обнаружить, что в базе данных что-то не так?

Да, ваши приложения могут быть спроектированы настолько идеально, что они всегда будут корректно работать с транзакциями и данными, не создавая sweep gap, большого количества активных транзакций, длительных снимков и так далее. Обычно этого не происходит. Хотя бы потому, что некоторые разработчики тестируют свои приложения под управлением 2-3 пользователей одновременно, не более. Таким образом, при настройке написанных приложений для 15 и более одновременных пользователей база данных может вести себя непредсказуемо. Конечно, многопользовательский режим может работать нормально, поскольку большинство многопользовательских конфликтов можно протестировать с помощью 2-3 одновременно работающих приложений. Но затем, когда будет запускаться больше одновременно работающих приложений, могут возникнуть проблемы со сборкой мусора (по крайней мере). И это можно поймать, если в правильные моменты снимать статистику.

==== Если у вас не возникают периодические проблемы с производительностью

Это может произойти, если ваши приложения спроектированы правильно, база данных не загружена или ваше оборудование современное и очень мощное (достаточно для хорошей обработки текущего количества пользователей и данных).

Самая ценная информация -- это транзакционная нагрузка и накопление версий. Это можно увидеть, только если настроить регулярное сохранение статистики.

Лучшая настройка -- получать почасовую статистику транзакций. Это можно сделать, запустив

[source,bash]
----
gstat –h db.gdb > db_stat_<time>.txt
----

где

* `db.gdb` -- имя вашей базы данных,
* `db_stat_<time>.txt` -- текстовый файл, в котором будет сохраняться статистика,
* `<time>` -- текущая дата и время, когда была снята статистика.

Также вы можете запланировать сбор статистики базы данных с помощью HQbird FBDataGuard, задание "`Database: Statistics`".

==== Если у вас периодически возникают проблемы с производительностью

Эти проблемы обычно вызваны автоматическим запуском sweep. Сначала вам нужно определить период времени между такими падениями производительности. Далее разделите этот интервал минимум на 4 (8, 16 и так далее). Сейчас в информационных системах много одновременно работающих пользователей, и большинство проблем с производительностью при ненастроенных сервере и базе данных происходят по 2 или 3 раза в день.

Например, если проблемы с производительностью возникают каждые 3 часа, вам необходимо собирать

[source,bash]
----
gstat –h db.gdb
----

статистику каждые 30-45 минут, и

[source,bash]
----
gstat –a –r db.gdb –user SYSDBA –pass masterkey
----

каждые 1-1.5 часа.

Лучше всего, когда вы соберёте статистику `gstat –a –r` прямо перед предстоящим падением производительности. Она покажет, где настоящий мусор и сколько скопилось устаревших версий записей.

==== Что делать с этой статистикой?

Если ваше приложение явно использует транзакции и использует их хорошо, т. е. вы знаете, что такое `read read_commit` и когда его использовать, ваши SNAPSHOT транзакции длятся не дольше, чем необходимо, и транзакции активны минимальный период времени, вы можете настроить sweep interval, или отключить его, а затем заботьтесь только о том, сколько обновлений делает приложение(я) и какие таблицы нужно меньше обновлять или заботиться об обновлениях.

Что это значит, спросите вы? Приведем пример некоторой системы, в которой каждое утро в течение 20-30 минут возникали проблемы с производительностью. Этого вполне обычно для "`утренних`" запусков приложений, и дольше оно не может продолжаться.

Администратору базы данных задали правильные вопросы, и вот картина:

Ежедневная работа была разделена на части: утром анализ данных, затем данные вставляются и редактируются обычными операторами, а в конце дня специальные процедуры начинают сбор данных, которые будут использоваться для аналитики на следующий день (как минимум).

Последняя работа над базой данных в конце дня заключалась в большом количестве обновлений, причем обновлений тех таблиц, которые аналитики использовали утром. Итак, появилось много мусорных версий, которые начало собирать приложение, работающее с утра.

Решение это проблемы оказалось простым -- запускать `gfix –sweep` в конце дня.

Sweep читает все таблицы в базе данных и пытается собрать в них все мусорные версии для зафиксированных и откаченных транзакций. После очистки базы данных стало ясно, почему улучшение происходит после восстановления.

И "`утренняя проблема`" ушла.

Итак, вам нужно понимать статистику с учетом множества других факторов:

* сколько одновременно пользователей (в среднем) работает в течение дня
* продолжительность рабочего дня (8, 12, 16, 24 часа)
* какие приложения работают в разное время суток и как они влияют на данные, используемые другими приложениями, работающими в то же время или в последующее время. Т.е. вы должны понимать бизнес-процессы, происходящие в течение всего дня и всей недели.


==== Когда DBA не может ничего сделать

К сожалению, такие ситуации случаются. И снова пример:

Некоторая система установлена примерно для 15 пользователей. Периодически производительность настолько падает, что администратору базы данных приходится перезагружать сервер. После перезагрузки сервера какое-то время все работает нормально, затем производительность снова падает. Статистика показала, что среднее количество транзакций в день составляет около 75000, и есть активные транзакции, выполняемые с начала дня до момента падения производительности.

К сожалению, приложения были написаны с использованием BDE и вообще без использования транзакций; то есть вся обработка транзакций была автоматической и использовалась самим BDE. Из-за этого некоторые транзакции оставались активными в течение длительного времени, а мусор (версии записей) накапливался до тех пор, пока администратор базы данных не перезапустил сервер. После перезапуска начнется автоматическая очистка, и мусор будет собран (устранен).

Все это было вызвано приложениями, потому что они тестировались только с 2-3 одновременными пользователями, а когда их стало ~15, приложения начали очень сильно нагружаться.

Надо сказать, что в этой конфигурации 70% пользователей только читали данные, а остальные 30% вставляли и обновляли какие-то (!) данные.

В этой ситуации единственное, что может улучшить производительность, — это перепроектировать управление транзакциями в этом приложении.

==== Как IBAnalyst может помочь найти проблемы в вашей базе данных Firebird

Давайте рассмотрим ключевые возможности IBAnalyst. Когда вы впервые просматриваете статистику своей базы данных в IBAnalyst, все может быть неясно, особенно если IBAnalyst показывает множество предупреждений в виде окрашенных в красный и желтый цвет ячеек в представлениях Summary, Tables и Index. Рассмотрим несколько примеров из реальной статистики.

=== Summary View

Summary содержит наиболее важную информацию, извлеченную из статистики базы данных. Обычно полная статистика базы данных содержит сотни Кбайт и распознать важную информацию непросто.

Ниже приведено описание объектов и параметров базы данных, которые вы можете увидеть в разделе Summary. Описание видимых проблем (отмеченных *красным* или **желтым**) смотри в подсказках для столбцов или выводе рекомендаций.

[cols="1,1", options="header"]
|===
| Объект или параметр
| Описание

|**Database name**
|Имя анализируемой базы данных.

|**Creation date**
|Дата создания базы данных. Когда она был создан оператором `CREATE DATABASE` или восстановлена (`gbak -c` или `gbak -r`).

|**Statistics date**
|Когда была получена статистика -- дата файла статистики или дата вызова service API (сейчас).

|**Page size**
|Размер страницы -- это физический параметр базы данных. В современных версиях Firebird размер страницы может быть 4096, 8192 или 16384 байта (Firebird __4.0+ может использовать размер страницы 32 КБ__). Для повышения производительности восстановите базу данных из резервной копии, используя размер страницы 8 или 16 КБ. 

|**Forced Write**
|Показывает режим записи измененных страниц: синхронизированный или асинхронный -- соответствующая настройка ON или OFF. OFF не рекомендуется, так как сбой сервера, сбой питания или другие проблемы могут привести к повреждению базы данных.

|**Dialect**
|Текущий диалект базы данных.

|**Sweep interval**
|Текущее значение sweep interval. Отмечено желтым, если оно не равно 0, и отмечено красным, если sweep gap больше sweep interval.

|**On Disk Structure**
|ODS. Это физический формат базы данных. Смотри подсказку, чтобы узнать номер ODS для конкретных версий IB/FB.

|**Transaction block**
|

|**Oldest transaction**
|

Oldest interesting transaction.

Идентификатор старейшей транзакции которая откачена или находится в состоянии limbo.

|**Oldest snapshot**
|

Oldest snapshot transaction

Идентификатор транзакции, которая была самой старой активной на момент запуска самого старого моментального снимка (snapshot).

|**Oldest active**
|

Oldest active transaction

Идентификатор самой старой все еще активной транзакции.

|**Next transaction**
|Идентификатор следующей транзакции.

|**Sweep gap (snapshot – oldest)**
|Для ODS 10.x. Разница между Oldest Snapshot и Oldest Interesting transaction. Если она больше sweep interval и sweep interval > 0, то Firebird попытается запустить sweep, и это может замедлить производительность.

|**Snapshot gap (active – oldest)**
|Разница между Oldest Active и Oldest transaction. То же самое что и sweep gap.

|**TIP size**
|Размер Transaction Inventory Pages, в страницах и килобайтах. TIP сохраняет состояние транзакции для каждой транзакции, запущенной с момента создания (или восстановления) базы данных. Он рассчитывается как Next transaction div 4 (байты).

|**Snapshot TIP Size**
|Размер Transaction Inventory Pages необходимых для snapshot транзакций. Отображает сколько памяти потребуется каждой snapshot транзакции для проверки состояния параллельных транзакций.

|**Active transactions**
|Количество активных транзакций (на момент взятия статистики из базы данных) `Next – Oldest Active`. Это неточная оценка, потому что может быть одна активная транзакция и множества завершённых после неё. В любом случае активные транзакции предотвращают сборку мусора.

|**Transactions per day**
|Просто делит Next transaction на количество дней между датой создания базы данных и датой сбора статистики. Показывает среднее количество транзакций в день. Это значение бесполезно, если это не рабочая база данных. Предупреждения о транзакциях в основном основаны на среднем количестве транзакций за день.

|**Data versions percent**
|Процент версий записей в базе данных. Также отображается общий размер записей и размер версий для всех таблиц, а также общий размер индексов. Строка не отображается, если статистика не содержит информации о количестве записей (`gstat -a` без опции `-r`). Обратите внимание, что в вашей базе данных может быть много других данных (transaction inventory pages, empty pages и т. д.).

|**Table/Index lists **(также отображается в рекомендациях)
|

|**Fragmented Tables**
|Here you can view tables (with data > 200 kilobytes) that have average fill less than 60% (File/Options/Table average fill).

|**Versioned Tables**
|List of tables that have Versions greater than Records, set in Options/Tables.

|**Tables fragmented with blobs**
|List of tables that have blob fields with data size less than database page size.

|**Massive deletes/updates**
|List of tables that had lot of data deleted/updated by one delete/update statement.

|**Very big tables**
|Tables that are close to technical InterBase limit (36 gigabytes per table). You will see warning beforehand problem can occur.

|**Deep Indices**
|Indices with depth more than 3 (Options/Index)

|**Bad Indices**
|Indices with big MaxDup and TotalDup values

|**Broken or incomplete indices**
|Indices with key count less than record count. This can happen when index is broken or when statistics is taken during index creation or re-activation.

|**Useless Indices**
|Indices with Unique column = 1. May be deleted or deactivated, because they are useless for index search or sort operations.

|**Tables with no records**
|List of tables with Records = 0. This can be by design (temporary tables), or they can be just forgotten by database developer.
|===

image::5.2.1.png[]


Summary page shows a lot of information, but the most valuable is transactions state (__please read description of possible transactions states in IBAnalyst help, it is available by clicking F1 or in menu Help__).

At this screenshot you can see that some transaction is active for a long time, "`60% of daily average`".
IBAnalyst marks such transaction's state by red, because this transaction may prevent accumulated versions to be considered as garbage by server, and so, to be garbage collected.
This is a possible reason of slowness: the more versions exist for some record, the more time it will takes to read it.

In order to find this long-running transaction you can use MON$Logger module of FBScanner, or perform direct query of `MON$` tables.
Then, to find out which tables were affected by long running transactions (tables with a lot of record versions) you need to go to "`Tables`" view of IBAnalyst.

=== Tables view

View *Tables* contains the information about all database tables.
It represents important statistical information about each table.
All table warnings are marked (see details below).

You can see the following columns (Columns *Records, RecLength, VerLen, Versions, Max Vers* are visible only if statistics was generated with `gstat -r` or with "`Include record/rec versions`" checkbox enabled):

[cols="1,1", options="header"]
|===
| Column
| Description


|**Records**
|Record count. Marked pink if table fragmented by blob fields which data is less than database page size. Hint shows real table fragmentation and average records if there were no blob fields. Such fragmentation can cause bad performance for big table joins or natural scans.

|**RecLength**
|Average record length. Depends on record data, especially on char/varchar columns data. Min physical record length is 17 bytes (record header + all fields are null), max – as declared in table. Statistics show this data without record header count, in this case RecLength can be 0 (if nearly all records are deleted)

|**VerLen**
|Average record version length. If it is close to RecLength, almost all record is being updated. If VerLen is 40-80% and not greater of RecLength, then Versions are mostly updates. If VerLen greater than 80-90% of RecLength, than maybe Versions are mostly deletes, or update is made by char/varchar columns with new, greater data. Marked *yellow* if it's size is greater than specified % (Options/Record/Version size) of average record size.

|**Versions**
|Current record version count. More versions slowdown table reads. Also lot of versions means that there is no garbage collection performed or records are not read by anyone. Marked *red* if version count is greater than Records. (Options/Record Versions).

|**Max Vers**
|Max record versions for one particular record. Marked blue when it is equal to 1 and Versions is non-zero. It means that there were massive update/delete operation. See Options, Table, Massive deletes updates option.

|**Data Pages**
|Allocated data pages

|**Size, Mb**
|`DataPages * Page Size`, in megabytes. I.e. this is total table size, records + versions. Graph shows percentage of that table from the whole data size.

|**Idx Size, Mb**
|Sum of all indices size for that table. Graph shows percentage of that value to total size of all indices.

|**Slots**
|Count of links to data pages. Empty links are Slots-Data Pages. Doesn't affect disk space or performance.

|**Average Fill**
|Average data page fill %. Can be computed as `(DataPages * Page_Size)/ Records * RecLength`. Low page fill means that table is "fragmented". Frequent updates/deletes can fragment data pages. Marked red if average fill rate is less than 60% (go to Options/Average Fill to adjust it). Marked yellow if it is an artifact of high table fragmentation when it's record is too small (11-13 bytes).

|**Real Fill**
|Because we found that Average Fill, calculated by `gstat`, sometimes gives wrong results (at least for tables with small blobs), we placed here calculated column, that counts average fill not by data pages, but by records+versions, including record header.

|**20%, 40%, 60% and 100% fill**
|Shows page count having corresponding fill rate. Can be turned on/off in Options dialog

|**Total %**
|How big is that table plus it's indices in %, related to other tables.
|===

image::5.2.2.png[]


At "`Tables`" view you can see tables and their important parameters: number of records, number of record versions, record length, maximum number of versions, etc.

You can sort this view to find the largest tables.
Especially we are interested tables with many record versions – many record versions will make garbage collection for affected tables longer.
Usually it is necessary to change update and delete algorithms to get rid of many record versions.

Row Versions show total versions count for particular table, and row Max Vers shows maximum versions reached by some record.
For example, if you look at table `SITE`, there are 40611 records, total versions are 76142, but one record has 501 versions.
Reading and parsing such packet from disk takes more time, so, reading this record is slower than reading others.

This picture also shows a lot of tables where data was deleted.
But, because of long running transaction, server can't delete these versions, and they still on disk, still indexed, and still being read by server when reading data.

=== Index view

View *Indices* represents all indices in your database.
You can estimate the effectiveness of indices with the following parameters (problem indices are marked *red* -- see smart hints for details)

[cols="1,1", options="header"]
|===
| Column
| Description


|**Depth**
|Index depth is the page count that engine reads from disk to walk from index root to record pointer. Optimal index depth is 3 or less. When Depth is 4 and higher, it is recommended to increase database page size (backup, then restore with `-page_size` option). This column will be marked red if index depth is greater than 3 (Options/Index/Index Depth). More chances to exceed optimal depth have indices built on long char/varchar columns.

|**Keys**
|Index key count. Usually equals to Records. If Keys is bigger
                                    than Records and Versions count is greater than 0 it means that
                                    concrete field value was changed in those record versions. If
                                    Table.RecVersions is bigger than Keys, than this index field(s)
                                    are not changed during updates.

|**KeyLen**
|Average index key length. The less KeyLen, the more equal or similar (postfix) values (keys) stored in index.

|**Max Dup**
|Maximum duplicates count for particular key value. Some old `gstat` versions show no more than 32767 or 65535 -- this bug is fixed in latest Firebird versions. Marked *red* if duplicates count is 30% of all keys. (Options/Index/Lot of key duplicates).

|**Total Dup**
|The overall count of keys with the same values.
Some old `gstat` versions show no more than 32767 or 65535 -- this bug is fixed in latest Firebird versions.

The closer this value to Keys count, the less effective will be searching using this index, especially when search is made using more than one index.
Total Dup value can be counted as Keys minus unique keys count (index statistics is nonlinear).

Marked *yellow* if `1/(Keys – TotalDup)` greater than 0.01, and red if in addition MaxDup is marked red too.
This constant (0.01) is used by optimizer (see sources in `opt.cpp`) as usable index selectivity border.
Optimizer will still use that index if none other index with better selectivity exists for some condition.

|**Uniques**
|Count of different key values. Primary and unique key indices will show same value as in Keys column. Useful to understand how many different values stored in index -- is it useful or not. Index is useless if Unique column shows 1 (marked yellow).

|**Selectivity**
|Information from `rdb$indises.rdb$statistics`, only visible if "`load table/index metadata`" was On. If selectivity stored in database differs from computed selectivity, *yellow* warning shown (less than 20% difference) or *red* (higher than 20% difference). *Blue* warning is shown when index is empty but it's selectivity is not 0. Selectivity of inactive indices are ignored.

|**Size, Mb**
|Index size in megabytes. Gap show percentage of that index size related to total size of all indices.

|**Average Fill**
|Average index pages fill rate, in %. Marked *red* if average fill rate is less than 50% (go to Options/Average Index Fill to adjust it). Fragmented index results more page reads as usual, and it's Depth can be higher. Can be fixed by alter index inactive/active, if it is not index created by primary, unique or foreign key constraints.

|**Leafs**
|Leaf page count (pages with keys and record pointers).

|**20%, 40%, 60% and 100% fill**
|Shows page count having corresponding fill rate. Can be turned on/off in Options dialog
|===

image::5.2.3.png[]


Some production databases can have indices with the only key value indexed.
This can happen because database was developed "`to be extended in the future`", or, someone just experimented with the indices during development or tests.
You can see these indices as "`Useless`" in IBAnalyst: `I_NUMBER`, etc, built on the column that has only one value for all rows.
These indices are really useless, because

* Optimizer may use this index if you specify "`where field =...`". Since field contains only one value, using index will cause useless reading of index pages from disk to memory, and consume memory (and time) when server will prepare which rows to show for that query.
* Creating indices is the part of restore process. Extra indices adds extra time.

Of course, that is not all that you can find about your database in IBAnalyst.
You can also find

* average number of transactions per day
* was there rollbacks or lost connections, and when
* how big (in megabytes) each table and index
* tables that have records interchanged by blobs, and thus reading only records is slower
* empty tables -- just forgotten, or empty at the time when statistics was taken
* indices with lot of duplicate keys (you can consider about column value distribution)
* indices with depth 4 and greater -- maybe you need to increase page size to speed up
