[[hqbird-monitoring]]
= Мониторинг

== Мониторинг с помощью HQbird FBDataGuard

=== Обзор

HQbird контролирует все аспекты функционирования сервера и базы данных Firebird, включая непрерывный и детальный мониторинг.

Непрерывный мониторинг осуществляет HQbird FBDataGuard. Это малоинвазивный, но очень эффективный мониторинг, который может помочь найти и устранить большинство проблем с производительностью и стабильностью баз данных.

FBDataGuard выполняет следующие действия по мониторингу:

* Дополнительный мониторинг производительности с помощью TraceAPI и MON$
* Мониторинг динамики маркеров транзакций (Next, OAT, OIT, OST, активные транзакции)
* Мониторинг активности таблицы блокировок (queues, deadlocks, mutexes)
* Мониторинг журнала Firebird (errors, warnings, messages)
* Количество подключенных пользователей
* Мониторинг свободного места для сервера, баз данных и их резервных копий
* Мониторинг работоспособности посредством анализа метаданных базы данных и общей доступности сервера и баз данных.
* Количество и размер временных файлов Firebird (сортировка и т. д.)
* Мониторинг индексов: целостность и активность
* Общая проверка базы данных Firebird
* Мониторинг статусов резервных копий
* Мониторинг доступности реплик

FBDataGuard может графически представлять информацию, собранную в ходе мониторинга, например о транзакциях и количестве пользователей:

.Динамика транзакций в FBDataGuard.
image::4.1.1.png[]


.Количество пользователей.
image::4.1.2.png[]


=== Автоматический мониторинг с помощью FBDataGuard (Trace API)

В HQBird 2020 представляет новый подход к автоматическому мониторингу производительности с помощью таблиц Firebird TraceAPI.

Теперь регулярную проверку работоспособности базы данных можно запланировать менее чем за 1 минуту.

Для этого просто откройте вкладку "`Производительность`" и настройте мониторинг транзакций и запросов:

image::4.1.3.png[]

Чтобы настроить Мониторинг производительности, укажите в диалоге его обязательные параметры:

image::4.1.4.png[]

Первый обязательный параметр -- "`*Включить мониторинг производительности*`" -- его необходимо включить для запуска трассировок по расписанию.

Следующие важные параметры -- "`Запустить трассировку в`"  и "`Остановить трассировку в`"
Они содержат выражения CRON, которые определяют, когда начинается и заканчивается трассировка.

*По умолчанию трассировка начинается в 10:30 и заканчивается в 11:00*. Рекомендуется принять график отслеживания в соответствии с вашими потребностями. Ниже вы можете увидеть таблицу с некоторыми популярными вариантами.

[cols="1,1,3"]
|===
2+h| Выражения CRON
.2+h| Описание

h| Старт
h| Завершение

|0 0 * ? * *
|0 10 * ?* *
|Запускать трассировку каждый час с 0 до 10 минут

|0 0 8 ? * *
|0 0 17 ?* *
|Запускать трассировку каждый день с 8:00 до 17:00

|0 30 10,13,15 ? * *
|0 0 11,14,16 ? * *
|Запускать трассировку каждый день с 10:30 до 11:00, с 13:30 до 14:00 и с 15:30 до 16:00

|===

Следующий важный параметр -- порог времени для медленных запросов, он задается в поле "`Логировать SQL-запросы с временем выполнения более чем (ms)`". В этом поле необходимо установить порог времени выполнения запросов (в миллисекундах), после его превышения запросы будут сохраняться и анализироваться.

По умолчанию время установлено на 1000 миллисекунд или 1 секунду. Это означает, что будут регистрироваться и анализироваться только запросы, которые выполняются более 1 секунды.

Мы рекомендуем использовать базовое значение 1000 мс, пока ваша база данных не станет очень медленной: в этом случае 3000-5000 мс могут быть хорошим началом.

Флажок "`Отправить e-mail`" указывает на необходимость отправки отчета о производительности. Настройки электронной почты из конфигурации оповещений будут использоваться для отправки отчета о производительности.

Для более сложных настроек в диалоговом окне "`Мониторинг производительности`" есть дополнительные параметры (обычно их настраивать не требуется).

image::4.1.5.png[]

* "`*Образец имени файла конфигурации*`" -- имя файла шаблона конфигурации, который следует использовать для настроек трассировки.
* "`*Фильтр выбора БД*`" -- как должна идентифицироваться база данных. Обычно "`АВТО`" достаточно, он отслеживает указанную базу данных. В случае "`ИМЯ_БД`" или "`ПСЕВДОНИМ`" для фильтрации событий базы данных будет использоваться имя файла или псевдоним. "`ВРУЧНУЮ`" предоставляет возможность задать любое регулярное выражение, например, для трассировки нескольких баз данных или более одного псевдонима для одной базы данных.
* "`*Database name filter*`" -- используется если выбран фильтр "`MANUAL`".
* "`*Сохранять N последних отчетов*`" -- указывает, сколько отчетов должно храниться в "`Каталог для хранения отчета`" для возможного ретроспективного использования.

В результате этого задания HQbird сформирует отчет о производительности, который будет сохранен в папке "`Каталог для хранения отчета`" в виде файла с расширением **html** и отправлен по электронной почте (в случае, если "`Отправить e-mail`" включен). Также самые последние отчёты доступны для просмотра и скачивания в интерфейсе HQBird.

image::4.1.6.png[]

=== Что показывает отчёт о производительности?

Анализ производительности HQbird FBDataGuard предоставляет 3 типа отчетов:

. список запросов, отсортированный по времени -- "`Sort by duration`";
. список запросов, отсортированный по частоте -- "`Sort by frequency`";
. список запросов, отсортированный по общему времени (т. е. суммарное время выполнения запросов с одинаковым текстом и различными параметрами) -- "`Sort by summary`".

В начале отчета вы увидите графическое представление наиболее проблемных SQL-запросов:

image::4.1.7.png[]

image::4.1.7-1.png[]

Когда вы нажмете "`Sort by duration`" (это опция по умолчанию), вы увидите SQL-запросы и хранимые процедуры, выполнение которых в первую очередь заняло больше всего времени.

Обычно они возникают на длительных отчетах и других больших SQL-запросов.

image::4.1.8.png[]

При нажатии на ссылку "`Sort by frequency`" в шапке отчета вы увидите наиболее частые запросы: т.е. те запросы, которые запускались часто (среди зарегистрированных запросов).

image::4.1.9.png[]

Например, если процедура `SP_GET_INVOICE_REPORT` (или другой запрос) была выполнена 46 раз, то это означает, что данный запрос сильно влияет на общую производительность, и его следует оптимизировать в первую очередь.

При нажатии на "`Sort by summary`" вы увидите запросы, которые заняли большую часть времени (среди зарегистрированных запросов). Эти запросы обычно являются лучшими кандидатами на оптимизацию.

image::4.1.10.png[]

==== Подробная информация по проблемным SQL-запросам.

Чтобы просмотреть детали наиболее частого запроса, нажмите ссылку "`View details`" внизу текста запроса:

image::4.1.11.png[]

В результате вы увидите самый длинный запрос среди запросов с одинаковым текстом SQL, с его планом выполнения, статистикой выполнения и входными параметрами.

Этой информации достаточно для анализа и оптимизации SQL-запроса в Firebird SQL Studio или другой IDE для разработчиков.

=== Как выбрать инструмент для детального мониторинга

FBDataGuard -- это первая линия защиты базы данных Firebird; как только FBDataGuard обнаруживает что-то подозрительное внутри контролируемых областей, он отправляет предупреждение с описанием проблемы.

[IMPORTANT]
====
Если у вас есть несколько серверов Firebird, мы предлагаем приложение HQbird Control Center, которое собирает данные оповещений с серверов и баз данных Firebird и отображает их на одном экране. Свяжитесь с нами для получения более подробной информации.
====

После получения такого предупреждения от FBDataGuard администратор базы данных должен приступить к детальному изучению проблемы.

Выбор инструмента для детального мониторинга зависит от типа обнаруженной проблемы.

Если FBDataGuard сообщает о длительно выполняемой активной транзакции (Next-OAT), необходимо использовать *HQbird Mon$Logger* для обнаружения источника текущей активной транзакции.

Если сообщается о зависании oldest interesting транзакции, администратор базы данных должен запланировать явный sweep для очистки несобранного мусора с помощью задания Sweep FBDataGuard (если это необходимо), а затем запланировать отслеживание принудительных откатов с помощью Мониторинга производительности в FBDataGuard.

Если пользователи сообщают о проблеме медленности выполнения некоторых запросов, следует использовать Perfusion или FBScanner.

Если в поведении транзакций наблюдаются необычные скачки, *IBTransactionMonitor* может стать хорошим дополнением к HQbird FBDataGuard для прояснения ситуации.

Проблемы с общей производительностью базы данных и периодические или периодические замедления требуют анализа структуры базы данных, который можно выполнить только с помощью HQbird Database Analyst.

Ниже мы рассмотрим более подробно, как работать с инструментами мониторинга HQbird.

<<<

== Мониторинг с помощью MON$ таблиц: HQbird MonLogger

HQbird MonLogger -- это инструмент для анализа вывода таблиц мониторинга в Firebird, поиска проблем с медленными SQL-запросами, неправильно спроектированных транзакций (длительно выполняемых транзакций, транзакций с неправильным уровнем изоляции и т. д.), а также выявления проблемных приложений.

MonLogger может подключиться к базе данных Firebird с проблемами производительности и определить причину медленности: какое пользовательское подключение, медленный SQL-запрос или длительная транзакция?

MonLogger поддерживает Firebird 2.1, 2.5, 3.0, 4.0 и 5.0 -- для более старых версий Firebird или InterBase используйте FBScanner.

MonLogger может показать вам:

* Топ соединений с наибольшим количеством операций ввода-вывода, не индексированных и индексированных чтений
* Топ SQL запросов с наибольшим количеством операций ввода-вывода, не индексированных и индексированных чтений
* Проблемные транзакции: длительные транзакции, транзакции с ошибочным уровнем изоляции, транзакции чтения/записи и сопутствующая информация: когда они начались, какие приложения запустили эти транзакции, с какого IP-адреса и т. д.
* Соединения и запросы с наиболее интенсивными действиями по сборке мусора
* Соотношение Read/write, соотношение INSERT/UPDATE/DELETE и другое.

После подключения к базе данных, в которой вы хотите обнаружить проблемы с производительностью, необходимо сделать несколько снимков таблиц мониторинга -- нажмите "`Get Snapshot`", чтобы сделать снимок

=== Агрегированная статистика производительности для пользовательских соединений

На первом экране мы можем увидеть агрегированную статистику подключений к базе данных и выявить соединения с наибольшими проблемами:

image::4.2.1.png[]

==== Sequential reads / Indexed reads

"`Sequential reads / Indexed reads`" показывает нам общее соотношение между последовательными (неиндексированными) чтениями и индексированными чтениями в приложении. Обычно количество неиндексированных чтений должно быть небольшим, поэтому большой процент последовательных чтений является признаком того, что многие SQL-запросы имею план выполнения `NATURAL`, и они могут быть причиной медленного времени ответа.

Щелкните на записи в разделе "`TOP attachments: sequential/indexed reads`", чтобы перейти на вкладку "`Attachments`", где можно просмотреть более подробную информацию о соединениях с БД, а затем перейти на вкладку  "`Transactions`" или "`Statements`", где вы увидите транзакции и запросы, связанные с выбранным соединением (если установлен флажок "`Link to selected attachment`", в противном случае будут показаны все транзакции/запросы для всех соединений).

==== Write details

"`Write details`" дает вам обзор операций записи: соотношение между INSERT/UPDATE/DELETE среди всех соединений базы данных. В таблице top writes вы можете увидеть соединения с наибольшим количеством операций записи. Полезно выявить приложения или программные модули, которые выполняют чрезмерное количество обновлений или удалений (они являются наиболее опасными операциями с точки зрения сборки мусора).

==== Garbage collection details

Что означают операции по сборке мусора?

* Purge -- движок удаляет бэк-версии, в базе данных находится только основная версия.
* Expunge -- как основная версия, так и все бэк-версии были удалены.
* Back-out -- удалена только основную версию (из-за rollback).

Обычно мы можем связать Purge с операцией `UPDATE`, Expunge с `DELETE`, и Backout с откатом `INSERT` или `UPDATE`. Множество backouts могут означать, что в приложении возникла проблема с управлением транзакциями.

==== Memory usage

График "`Memory usage`" показывает общий объем памяти, используемый всеми активными соединениями сейчас, и пик выделенной памяти для них в прошлом.

Топ соединений по объему использования памяти показывает, какие ваши соединения больше всего потребляют память. Полезно найти приложения или программные модули с чрезмерным использованием памяти.

=== Aggregated performance statistics for statements

На второй вкладке вы можете найти агрегированную статистику производительности SQL запросов.

image::4.2.2.png[]

Эта статистика лучше отражает текущую ситуацию в базе данных -- поскольку таблицы мониторинга собирают информацию с начала жизни каждого объекта, здесь вы можете увидеть операторы, которые выполнялись в момент создания моментального снимка.

==== Sequential reads / Indexed reads

В этом списке мы видим топ запросов, которые выполняют множество операций последовательного чтения из базы данных. Обычно такие запросы требуют настройки SQL -- либо путем создания индексов индексов, либо путем изменения конструкции SQL-запроса.

Чтобы настроить запрос, проверьте план его выполнения: обычно можно повысить скорость запроса, исключив из планов `NATURAL` с помощью новых индексов или переписывания запроса. Щёлкните по запросу в этом списке, чтобы открыть вкладку "`Statements`", где вы сможете найти более подробную информацию о выбранном запросе и перейти к соответствующей транзакции или соединению.

==== Page reads/page writes

На этих графиках и в списке представлена краткая информация о топе SQL запросов, которые выполняют много операций чтения -- это означает, что они потребляют значительный объем операций ввода-вывода и могут повлиять на производительность других запросов. SQL запросы с пиковыми значениями следует тщательно проверять на предмет оптимальной производительности.

==== Write details для запросов

На этом графике вы можете увидеть, что записывали SQL операторы в момент создания снимка таблиц мониторинга, а также определить UPDATEs и DELETEs, которые внесли много изменений в базу данных.

==== Garbage collection details для запросов

На этом графике мы видим, сколько операций по сборке мусора было выполнено SQL запросами, выполнявшимися в момент создания снимка.

==== Memory usage для запросов

В отличие от агрегированной статистики использования памяти для соединений, использование памяти SQL запросами может показать нам список точных операторов, которые в данный момент потребляют много памяти.

=== Attachments

Третья вкладка -- "`Attachments`". Вы можете открыть эту вкладку и перейти туда, щелкнув одну из записей в разделе "`Aggregated performance statistics`".

image::4.2.3.png[]

"`Attachments`" показывает список пользователей, подключенных к базе данных Firebird, со многими полезными подробностями: `USER` и `ROLE` для соединения, время начала и идентификатор соединения, включена ли сборка мусора для соединения, имя удаленного процесса, установившего соединение, и несколько накопленных счетчиков производительности для соединения: количество последовательных чтений (выполненных соединений с момента его запуска), количество индексированных чтений, количество вставок, обновлений и удалений, а также количество backouts, purges и expunges.

По умолчанию некоторые столбцы соединения отключены, чтобы отображалась только самая важная информация.

Конечно, каждый раз, когда вы щёлкаете по соединению, вы можете перейти к транзакциям, выполняемым внутри него, а затем к запросам. В левом верхнем углу вкладок "`Transactions`" и "`Statements`" есть флажок, который управляет поведением: если этот флажок установлен, будут отображаться только транзакции и запросы, по выделенному идентификатору соединения.

=== Transactions

Закладка "`Transactions`" показывает активные транзакции на момент создания снимка.

image::4.2.4.png[]

Если установлен флажок "`Link to selected attachment`" будут показаны только транзакции для выбранного соединения, в противном случае показаны все транзакции.

Одной из наиболее важных характеристик является время жизни транзакций: поскольку Firebird предназначен для работы с короткими пишущими транзакциями, важно сделать их как можно более короткими. MonLogger выделяет транзакции с режимами изоляции и read-write настройками, которые содержат Oldest Active транзакцию и, следовательно, приводят к тому, что они накапливают чрезмерное количество версий записей. Если вы видите такую транзакцию и она началась некоторое время назад, это означает, что она может быть ответственна за чрезмерное накопление версий записей.

Выполните сортировку по столбцу "`started at`" и найдите старые транзакции, отмеченные красным: все транзакции, доступные для записи, и snapshot транзакции, доступные только для чтения, приводят к застреванию в Oldest Active Transaction и вызывают удержание чрезмерного количества версий записей. Определите, где начались эти транзакции (щелкните правой кнопкой мыши и выберите "`View parent attachment`") и исправьте свой код, чтобы фиксировать эту транзакцию раньше.

=== Statements

image::4.2.5.png[]

На вкладке "`Statements`" показаны SQL операторы, активные на момент создания снимка: если вам нужно перехватить все операторы, то следует использовать FBPerfMon или FBScanner (все эти инструменты являются частью IBSurgeon Optimization Pack).

Если включена опция "`Link to selected attachment`", то будут показаны только SQL запросы для конкретного соединения, в противном случае в списке будут все активные запросы.

Некоторые операторы не имеют связанного идентификатора транзакции (=0): эти запросы подготавливаются, но не выполняются.

<<<

[[hqbird-advanced-monitor-viewer]]
== Advanced Monitor Viewer

Advanced Monitor Viewer позволяет графически отображать дополнительные счетчики производительности. Они основаны как на данных трассировки, так и на данных таблиц мониторинга, плюс используются дополнительные системные утилиты, такие как wmic (Windows).

Для запуска "`Advanced Monitor Viewer`" нажмите на соответствующий пункт меню "`Пуск`" menu:IBSurgeon[HQbird Server Side 2024 > Advanced Monitor Viewer] или запустите скрипт `AVM/quick_start.cmd`.

После успешного запуска в браузере по умолчанию откроется страница `http://127.0.0.1:8083`.

Вам будет предложено войти в систему:

image::4.4.1.png[]

Логин и пароль по умолчанию такие же, как и для DataGuard: "admin / strong password".

После успешной аутентификации откроется страница с панелью, на которой расположены различные графики, отображающие загрузку системы в разные моменты времени.

В левой части страницы вы увидите две кнопки: "`Properties`" и "`Databases`". Первая открывает контекстное меню для выбора счетчиков, которые будут отображаться на графиках. Вторая, открывает контекстное меню, в котором можно выбрать базу данных, для которой отображаются эти счетчики. База данных должна быть зарегистрирована для мониторинга с помощью DataGuard.

image::4.4.1-1.png[]

Вверху страницы отображается название базы данных, закладки с датами, а также интервал времени, за который отображаются счетчики производительности. Вы можете изменить дату просмотра и выбрать нужный интервал.

image::4.4.2.png[]

Следующие счетчики могут быть отображены графически:

=== Fetches, Reads, Writes, Marks

На графике отображаются счетчики производительности Fetches, Reads, Writes, Marks на основе таблиц мониторинга. Вы можете перейти к каждому моменту времени, щелкнув по нему или выбрав "`Data for time`" из списка.

image::4.4.3.png[]

=== Users

На графике отображается количество активных пользователей и запросов, а также время пинга. Вы можете перейти к каждому моменту времени, щелкнув по нему или выбрав "`Data for time`" из списка.

image::4.4.4.png[]

=== Traces

На графике отображаются счетчики производительности:  Fetches, Reads, Writes, Marks и время выполнения запроса на основе данных из журналов трассировки. Вы можете перейти к каждому моменту времени, щелкнув по нему или выбрав "`Data for time`" из списка.

image::4.4.5.png[]

=== RAM and CPU Windows

На графике отображается потребляемая память, а также загрузка процессора на основе отслеживания утилитой wmic.

image::4.4.6.png[]

=== RAM and LoadAvg Linux

То же, что "`RAM and CPU Windows`", только в Linux.

=== Transactions

На графике отображается количество активных транзакций и разрыв между счетчиками OST-OIT, Next-OAT.

image::4.4.7.png[]

=== Lock Table Info

На графике отображаются данные по нагрузке на менеджер блокировок (актуально в Classic и SuperClassic).

image::4.4.8.png[]

<<<

== Мониторинг с помощью HQbird FBScanner

=== Что такое FBScanner?

FBScanner (Firebird Scanner) -- это инструмент, включенный в расширенный дистрибутив HQbird, который может отслеживать и просматривать весь трафик между серверами Firebird и InterBase и их клиентскими приложениями.

Он показывает активность подключенных клиентов в реальном времени:

* Соединения (IP/имя, продолжительность, загрузка процессора),
* Запросы (текст запроса, статус, параметры)
* Транзакции (с параметрами).

FBScanner может регистрировать весь SQL-трафик в текстовых файлах и во внешней базе данных Firebird. Он включает модуль FBScanner LogAnalyzer для анализа производительности SQL.

FBScanner можно использовать для профилирования приложений баз данных, мониторинга активности пользователей и управления подключениями к базе данных (включая отключения клиентов на архитектурах Classic, SuperClassic и SuperServer). Он также идеально подходит для устранения ошибок INET, а также для аудита существующих приложений и настройки производительности.

FBScanner поддерживает Firebird (V1.x, V2.0, V2.1 и V2.5), InterBase (от V4.0 до 2009/XE3). Это полезный инструмент для анализа производственных баз данных, особенно если приложение разработано сторонней организацией и исходный код отсутствует.

FBScanner прозрачен в отношении приложения базы данных и не требует каких-либо изменений в исходном коде, логике или конфигурации приложения или базы данных.

=== Проблемы, которые FBScanner может помочь решить

* Мониторинг соединений в режиме реального времени. FBScanner показывает все подключения к выбранному серверу базы данных: IP/DNS-имя подключенного клиента, базу данных и время подключения.
* Мониторинг SQL-запросов в режиме реального времени. Для каждого соединения FBScanner показывает все текущие SQL-запросы вместе с параметрами их транзакций.
* Обнаружение самого старого соединения и самой старой активной транзакции, что позволяет вам проанализировать, что транзакция может иметь неоптимальное поведение или неправильный дизайн транзакции, или показать пользователей, которые могут использовать приложение таким образом, который может повлиять на производительность.
* Отключения клиентов. Проверка правильности выполнения отключений. Вы также можете использовать FBScanner для отключения пользователей для выполнения обслуживания или обновления базы данных.
* FBScanner позволяет маршрутизировать определенные приложения или отдельных пользователей, чтобы вы могли увеличить масштабируемость конкретных приложений или пользователей.
* Вы можете регистрировать SQL-запросы. Для отладки или в целях безопасности FBScanner может регистрировать весь выбранный трафик в специальную базу данных для дальнейшего анализа. FBScanner включает в себя инструмент LogAnalyzer для поиска плохих запросов и неэффективных планов SQL.

=== Влияние на производительность

FBScanner ничего не меняет в передаваемом SQL-трафике и работает просто как прозрачный прокси, поэтому все приложения будут работать нормально.

FBScanner потребляет примерно 50-150Мб памяти (для 30-100 активных клиентов), известно, что FBScanner добавляет примерно 150мс на каждый оператор SQL.

=== Как настроить FBScanner на локальном компьютере?

Чтобы настроить FBScanner, запустите "`FBScanner Service Settings`" из меню "`Пуск`" menu:IBSurgeon[HQbird Server Side > Firebird SQL Scanner]. тот инструмент поможет вам настроить как базовые, так и расширенные параметры конфигурации для FBScanner.

Основные параметры конфигурации отображаются на главном экране "`FBScanner Configuration`". Он сканирует реестр Windows на наличие установленных служб Firebird и отображает их в таблице.

image::4.3.1.png[]

По умолчанию Firebird использует порт 3050 для сетевых подключений.

FBScanner работает как прозрачный TCP-прокси -- он перенаправляет весь SQL-трафик от клиентов к Firebird.

FBScanner предлагает изменить порт Firebird на 3053, чтобы запустить собственный экземпляр на порту 3050. FBScanner проверяет использование порта, и если 3050 или 3053 используются другим программным обеспечением (не Firebird), он предупредит вас красной надписью "`Port used`" рядом с полем "`Port`".

Зеленый рисунок в центре главного экрана "`FBScanner Configuration`" кратко показывает, как будет передаваться SQL-трафик клиентских приложений.

На рисунке ниже вы можете видеть, что FBScanner обнаружил экземпляр Firebird 1.5 и предлагает изменить его порт на 3053, чтобы настроить собственный экземпляр на прослушивание порта 3050.

Такой сценарий по умолчанию обеспечит максимальную совместимость с существующими клиентами Firebird (т. е. приложениями конечного пользователя).

Чтобы утвердить изменения, нажмите "`Ok`", в противном случае -- "`Cancel`".

[IMPORTANT]
====
Если настройки FBScanner были изменены, служба FBScanner будет перезапущена, а все существующие соединения Firebird будут разорваны! Будьте осторожны при изменении настроек FBScanner в производственной среде. FBScanner запросит ваше разрешение на перезапуск, пожалуйста, принимайте решение обдуманно.
====

=== Как настроить FBScanner для удаленном компьютере?

FBScanner может маршрутизировать SQL-трафик не только как локальный прокси, но и с другого компьютера. Чтобы понять разницу и обнаружить последствия, давайте разберемся в деталях.

Базовая (и по умолчанию) конфигурация FBScanner подразумевает, что он работает на том же компьютере, на котором работает Firebird, и обрабатывает весь SQL-трафик от клиентов Firebird (т. е. приложений конечного пользователя), которые используют строку подключения по умолчанию (и, следовательно, порт 3050).

image::4.3.2.png[]

Иногда не удобно настраивать FBScanner на обработку всех запросов, например, в случае:

* Необходимо профилировать/логировать только несколько (возможно, одну) рабочих станций.
* Необходимо профилировать только определенное приложение или узкую функциональность
* Разработчикам необходимо проверить некоторый код SQL в действующей базе данных -- собрать статистику выполнения SQL, планы и т. д.
* Большая нагрузка (слишком много рабочих станций). В случае большой нагрузки FBScanner может потреблять ресурсы основного сервера, поэтому лучше перенести FBScanner (а также журнал FBScanner, если он включен, на выделенный компьютер).
* Linux-сервер. Если Firebird работает в Linux, можно маршрутизировать SQL-трафик через удаленный экземпляр FBScanner в Windows.

В таких случаях хорошей идеей будет настроить FBScanner на удаленном компьютере и пропускать через него только часть SQL-трафика. Это также позволяет выполнить необходимый анализ SQL без изменения портов или другой конфигурации на сервере -- единственной необходимой корректировкой будет изменение имени хоста в строках подключения клиентских приложений.

Одним из частых вариантов использования FBScanner в удаленной конфигурации является использование его в качестве консоли отладки для компьютера разработчика, чтобы разработчик мог видеть в режиме реального времени (с помощью FBScanner LogViewer) или впоследствии (с помощью FBScanner LogAnalyzer) все SQL-запросы со своего компьютера на сервер Firebird.

На рисунке ниже вы можете увидеть, как это может выглядеть:

image::4.3.3.png[]

Теперь вернемся к настройке и посмотрим, насколько легко настроить FBScanner для маршрутизации SQL-трафика на удаленном компьютере.

В нижней части главного экрана "`FBScanner Configuration`" вы можете увидеть следующие настройки по умолчанию (для примера Firebird 1.5, который мы рассматривали выше):

image::4.3.4.png[]

Чтобы настроить FBScanner для маршрутизации SQL-трафика на удаленный Firebird, нам нужно изменить "`Server Type`" с "`Local...`" на "`Remote`". Это изменит главный экран инструмента конфигурации.

Прежде всего, нам необходимо указать сетевое имя (или IP) компьютера с экземпляром Firebird и порт, на котором он будет использоваться -- его необходимо ввести в текстовое поле "`Interface`".

Затем нам нужно указать версию Firebird -- в нашем примере это Firebird 1.5.

Экземпляр FBScanner также имеет "`Interface`" -- это список сетевых адаптеров, обнаруженных на компьютере. Если вам нужно привязать FBScanner к одному из них и отключить подключения от других сетевых адаптеров, выберите один из адаптеров из раскрывающегося списка. По умолчанию FBScanner принимает запросы клиентов Firebird от всех сетевых адаптеров.

Ниже вы можете увидеть пример конфигурации FBScanner для маршрутизации SQL-трафика на удаленный экземпляр Firebird, который находится на компьютере *myserver1* и работает через порт 3050.

image::4.3.5.png[]

Нажмите "`Ok`", чтобы подтвердить новые настройки, и FBScanner направит SQL-запросы на удаленный Firebird.

[IMPORTANT]
====
Если вам необходимо передать трафик SQL от клиентских приложений через удаленный FBScanner, измените соответствующую строку подключения Firebird. Например, если изначально клиентские приложения подключались к "`*myserver1:C:\Database\data.fdb*`", чтобы передать SQL-трафик через FBScanner в этом примере, вам необходимо изменить строку подключения на "`*computer1:C:\Database\data.fdb*`" (где `computer1` -- сетевое имя компьютера, на котором работает FBScanner).
====

=== Как настроить логирование?

В меню "`Пуск`" запустите "Firebird Scanner > FBScanner Settings", затем нажмите кнопку "`Advanced options`" (в правом нижнем углу главного экрана).

image::4.3.6.png[]

В диалоговом окне выберите вкладку "`SQL log`".

image::4.3.7.png[]

По умолчанию ведение журнала отключено.

[IMPORTANT]
====
Важно понимать, что при журналировании в базу данных SQL будут записываться все операции SQL, включая транзакции, соединения и т. д. Это означает, что база данных журналов SQL будет потреблять то же количество ресурсов (ЦП, жесткий диск и т. д.), что и основная база данных. В связи с этим для сред с высокой нагрузкой мы рекомендуем использовать удаленную настройку FBScanner для ведения журнала SQL.
====

Есть два варианта ведения журнала: в файл и в базу данных журналов Firebird.

==== Логирование в текстовые файлы

Логирование в файлы создает текстовый файл для каждого соединения, в котором FBScanner записывает операторы SQL и транзакции. Мы рекомендуем логирование в файлы в целях отладки и во время разработки -- оно подходит для исследования линейного кода SQL. Если подключений много, логирование в файлы становится не очень подходящим.

Чтобы включить ведение журнала в файлы, установите переключатель рядом с опцией "`File`" и укажите папку, в которой будут храниться файлы журналов (сначала проверьте, существует ли указанная папка!):

image::4.3.8.png[]

Затем нажмите "`Ok`".

[IMPORTANT]
====
Включение ведения журнала потребует перезапуска службы FBScanner, поэтому все текущие соединения будут разорваны. FBScanner немедленно попросит вашего разрешения сделать это.
====

==== Пример логирования в текстовые файлы

Для следующих команд в `isql`

[listing]
----
Use CONNECT or CREATE DATABASE to specify a database

SQL> connect "localhost:E:\Temp\TEST15_2.FDB";
Database:  "localhost:E:\Temp\TEST15_2.FDB"

SQL> create table t1(i1 integer, c1 varchar(150));
SQL> create table t2(i2 integer, b1 blob);
SQL> select count(*) from t1;

COUNT
============
0

SQL> insert into t1(i1, c1) values(1, 'test');
SQL> select count(*) from t1;

COUNT
============
1

SQL> exit;
----

FBScanner создал следующий журнал:

[listing]
----
/* Log created by FBScanner v2.7.19
14.01.2011 16:06:07
	  Client IP      = 127.0.0.1
	  Client Name    = ibsurgeon3
	  Client Process = isql [1884]
*/
CONNECT '127.0.0.1/3053:E:\Temp\TEST15_2.FDB' USER 'SYSDBA';

/* 14.01.2011 16:06:09 */
/* TrID=20; */
SET TRANSACTION READ WRITE WAIT SNAPSHOT;

/* 14.01.2011 16:06:09 */
/* TrID=22; isc_tpb_version1, isc_tpb_write, isc_tpb_read_committed, isc_tpb_wait,
   isc_tpb_no_rec_version */
SET TRANSACTION READ WRITE WAIT ISOLATION LEVEL READ COMMITTED NO RECORD_VERSION;

/* 14.01.2011 16:06:19 */
/* QrID=26 TrID=22; EXECUTE */
create table t1(i1 integer, c1 varchar(150));

/* 14.01.2011 16:06:19 */
/* QrID=26 TrID=22; INFO */

/* 14.01.2011 16:06:19 */
/* TrID=22; */
COMMIT;

/* 14.01.2011 16:06:33 */
/* TrID=27; isc_tpb_version1, isc_tpb_write, isc_tpb_read_committed, isc_tpb_wait,
   isc_tpb_no_rec_version */
SET TRANSACTION READ WRITE WAIT ISOLATION LEVEL READ COMMITTED NO RECORD_VERSION;

/* 14.01.2011 16:06:33 */
/* QrID=31 TrID=27; EXECUTE */
create table t2(i2 integer, b1 blob);

/* 14.01.2011 16:06:33 */
/* QrID=31 TrID=27; INFO */

/* 14.01.2011 16:06:41 */
/* TrID=32; isc_tpb_version1, isc_tpb_write, isc_tpb_read_committed, isc_tpb_wait,
   isc_tpb_no_rec_version */
SET TRANSACTION READ WRITE WAIT ISOLATION LEVEL READ COMMITTED NO RECORD_VERSION;

/* 14.01.2011 16:06:41 */
/* QrID=36 TrID=20; EXECUTE */
select count(*) from t1;

/* 14.01.2011 16:06:41 */
/* QrID=36 TrID=20; INFO */

/*
	Fetch count     = 1
*/

/* 14.01.2011 16:07:11 */
/* QrID=38 TrID=20; EXECUTE */
insert into t1(i1, c1) values(1, 'test');

/* 14.01.2011 16:07:17 */
/* QrID=40 TrID=20; EXECUTE */
select count(*) from t1;

/* 14.01.2011 16:07:17 */
/* QrID=40 TrID=20; INFO */

/*
	Fetch count     = 1
*/

/* 14.01.2011 16:07:26 */
/* TrID=32; */
COMMIT;

/* 14.01.2011 16:07:26 */
/* TrID=27; */
COMMIT;

/* 14.01.2011 16:07:26 */
/* TrID=20; */
COMMIT;
----

Как видите, лог в файл полезен для понимания того, как команды SQL выполнялись внутри одного соединения.

==== Логирование в базу данных Firebird

Прежде чем начать работу с журналом SQL, необходимо понять некоторые детали реализации, которые могут быть важны для производственных систем.

В основном запись в базу данных Firebird осуществляется простым способом: служба FBScanner записывает весь трафик во внешнюю базу данных Firebird. База данных Firebird с журналом может находиться на том же компьютере, где находится FBScanner, или на удаленном компьютере.

Примите во внимание следующие требования к настройке журнала SQL:

* База данных журналов (и соответствующий экземпляр Firebird) должна быть в формате Firebird 2.5 (начиная с FBScanner 2.7.15). Если вы вынуждены использовать FBScanner на компьютере с другой версией Firebird, вам необходимо использовать Firebird 2.5 embedded для хранения журнала.
* SQL-трафик от всех зарегистрированных соединений записывается в единую таблицу с соответствующими маркерами (с какого компьютера, приложения, пользователя и т.д. была создана данная конкретная запись).
* База данных журналов может потреблять значительное количество ресурсов в случае большой нагрузки. В случае большого количества подключений рекомендуется настроить базу данных журналов FBScanner и Firebird на выделенном компьютере.
* Во многих случаях протоколировать все соединения нет необходимости, поскольку они повторяют один и тот же набор SQL-запросов. Тщательное исследование отдельного соединения может оказаться наиболее эффективным способом обнаружения проблем с производительностью.

Чтобы включить ведение журнала SQL, выберете "`SQL`" в переключателе. Это активирует соответствующие текстовые поля и элементы управления.

image::4.3.9.png[]

Прежде всего, нажмите кнопку "`Edit`".

image::4.3.10.png[]

[IMPORTANT]
====
Если вы собираетесь использовать один и тот же экземпляр Firebird для регистрации трафика SQL, вам необходимо указать строку подключения с явным портом.
В нашем примере это будет порт 3053, а строка подключения будет иметь вид `127.0.0.1/3053:C:\FBScanner_log.fdb`
====

В этом диалоговом окне вам также необходимо указать, как подключиться к базе данных с журналом.

Если базы данных с указанным именем нет, создайте новую базу данных -- нажмите "`Create database log`".

Проверьте соединение с базой данных журналов -- нажмите "`Test connection`".

Нажмите "`Ok`", чтобы сохранить настройки.

==== Маркеры транзакций

FBScanner может собирать информацию о маркерах транзакций (так же, как это делает IBSurgeon Transaction Monitors). Собранная информация будет отображаться в виде графиков в FBScanner Log Analyzer.

Для этой цели FBScanner запускает отдельное соединение, для которого требуются логин, пароль и путь к соответствующей клиентской библиотеке (если вы отслеживаете Firebird 1.5 с помощью FBScanner, потребуется `fbclient.dll` из 1.5).

Если вы решили собирать информацию о маркерах транзакций, отметьте флажок "`Collect transactions counters info`" и заполните поля "`Login`", "`Password`" и "`Client DLL`".

==== Использование Firebird 2.5 embedded для журнала SQL

Если вам необходимо использовать журнал SQL на компьютере, где используется старая версия Firebird (1.0, 1.5, 2.0, 2.1 или даже InterBase), для хранения журнала рекомендуется использовать Firebird 2.5 Embedded.

Вы можете загрузить Firebird 2.5 Embedded по адресу https://www.firebirdsql.org[www.firebirdsql.org].

Распакуйте архив прямо в папку FBScanner (по умолчанию `C:\Program Files\IBSurgeon\Firebird Scanner`) и переименуйте `fbembed.dll` в `fbclient.dll`.

Структура папок будет выглядеть так

image::4.3.11.png[]

После этого запустите "`Advanced options`", вкладка "`SQL logging`", переключатель "`SQL`" и нажмите "`Edit`", затем в "`Client library`" укажите переменованный файл `fbclient.dll`, как показано ниже.

image::4.3.12.png[]

[TIP]
====
В Embedded Firebird `fbclient.dll` представляет собой весь движок.
Он работает внутри процесса FBScanner и не взаимодействует с другими установленными экземплярами Firebird, как полными, так и встроенными.
====

=== Как проанализировать журнал FBScanner?

Многие пользователи рассказали нам, что не осознают, сколько запросов, транзакций и других операций выполняет их программное обеспечение. Как вы помните, FBScanner хранит всю информацию в одной таблице. Эта таблица использует ссылки на саму себя для уменьшения объема хранимой информации, что затрудняет чтение и понимание необработанного журнала.

Для облегчения анализа журналов мы создали в FBScanner новый модуль -- LogAnalyzer. Он доступен в IBSurgeon Deploy Center для всех пользователей FBScanner (в разделе "`Download`").

LogAnalyzer требует Firebird 2.5 для работы с базой данных журналов. Он также создает новые индексы и выполняет сложные запросы для отчетов, поэтому рекомендуется следующая процедура:

. Настройте ведение журнала и сбор статистики минимум за 1 день.
. Скопируйте базу данных журналов на другой компьютер с Firebird 2.5
. Подключитесь к копии базы данных журналов и выполните анализ на компьютерах разработчика.
. При необходимости скопируйте обновленные версии баз данных журналов.

Чтобы проанализировать базу данных журналов, запустите LogAnalyzer и нажмите "`Connect to FBScanner log base`", затем заполните параметры подключения и выберите базу данных журналов.

image::4.3.13.png[]

При первом запуске LogAnalyzer создаст необходимые индексы, это может занять несколько минут.

После этого LogAnalyzer отобразит последний доступный день в журнале на вкладке "`Server Load`":

image::4.3.14.png[]

Вкладка "`Server Load`" показывает, сколько SQL-запросов было выполнено в минуту и сколько времени потребовалось для их выполнения. Фактически он показывает загрузку сервера, то есть количество запросов и время их выполнения.

Увеличьте масштаб (кнопка в левом верхнем углу вкладки "`Server load`"), перетащите график, удерживая правую кнопку мыши, и выберите пик, который вы хотите исследовать -- щелкните правой кнопкой мыши, чтобы открыть всплывающее меню.

image::4.3.15.png[]

Он покажет вам вкладку "`All statements`", где вы можете просматривать SQL-запросы.

image::4.3.16.png[]

Выберите любой запрос, чтобы просмотреть его текст и, если функция ведения журнала плана включена, его план.

Чтобы проследить за ходом выполнения, вы можете щелкнуть запрос правой кнопкой мыши и найти соединение и транзакцию для этого запроса.

image::4.3.17.png[]

LogAnalyzer выделяет запросы в одной транзакции жирным шрифтом:

image::4.3.18.png[]

Вы можете отсортировать запросы и, например, найти запрос с наибольшим временем выполнения:

image::4.3.19.png[]

Чтобы узнать больше об этом запросе, дважды щелкните его и просмотрите более подробную информацию.

image::4.3.20.png[]

=== Как отслеживать ошибки 10054, отключения и неудачные попытки входа в систему?

FBScanner автоматически регистрирует все 10054 ошибки, отключения и неудачные попытки входа в систему с подробным описанием в файле `FBScanner.log`, который находится в главном каталоге FBScanner.

[listing]
----
19.08.2010 21:43:09
	Connect Error
	  Client IP      = 192.10.1.2
	  Client Name    =
	  DB Name        =
	  DB User        = MORTON
	  Client Process = SUPC [5520]
	  Client Process (by fbclient) = E:\TEMP\TEST1.EXE [5520]
	  STATUS         = [file  is not a valid database]


19.08.2010 21:43:25
	Login Failed
	  Client IP      = 127.0.0.1
	  Client Name    = ibsurgeon3
	  DB Name        = C:\Program Files\Jupiter2010\Data\data.gdb
	  DB User        = MORTON
	  Client Process = Jupiter.exe [3032]
	  Client Process (by fbclient) = E:\TEMP\TEST1.EXE [3032]
	  STATUS         = [Your user name and password are not defined.
Ask your database administrator to set up a Firebird login.]
----

=== Операции Backup/restore и массовой загрузки

Для выполнения операций, не требующих мониторинга или отладки, таких как резервное копирование и восстановление или массовая загрузка записей (в биллинговых системах), мы рекомендуем обходить сервис FBScanner.

Если FBScanner установлен в рекомендуемой конфигурации по умолчанию, т. е. на порту 3050, а Firebird -- на порте 3053, строки подключения должны быть такими:

[listing]
----
server_name/3053:Disk:\Path\database.fdb
----

пример строки подключения

[listing]
----
connect "localhost/3053:C:\TEMP\database.fdb" user "SYSDBA" password "masterkey";
----

Пример использования команды резервного копирования

[listing]
----
gbak.exe -b -g -v -user SYSDBA -pass masterkey localhost/3053:C:\TEMP\database.fdb C:\temp\backup.gbk
----

Конечно же, использование локальной строки подключения всегда будет обходить FBScanner:

[listing]
----
gbak.exe -b -g -v -user SYSDBA -pass masterkey C:\TEMP\database.fdb C:\temp\backup.gbk
----

=== Мониторинг в реальном времени: FBScanner Viewer

Для мониторинга соединений, запросов и транзакций в режиме реального времени FBScanner включает в себя специальный инструмент, а именно FBScanner Viewer.

FBScanner Viewer показывает мгновенный снимок SQL-трафика между Firebird и контролируемыми клиентскими приложениями.

image::4.3.21.png[]

В первом столбце мы видим тип записи -- connection, statement или transaction.

В таблице ниже вы можете найти описание всех столбцов на главной странице FBScanner Viewer (некоторые столбцы по умолчанию скрыты, используйте меню "`Columns`" чтобы включить/выключить их):

[cols="1,1", options="header"]
|===
| Наименование столбца
| Описание


|! (первый столбец)
|Указывает тип записи в FBScanner Viewer -- для операторов SQL, транзакций и соединений имеется отдельный набор значений.
Они описаны в следующей таблице ниже.

Знак "`!`" в заголовке этого столбца означает активный фильтр -- нажмите на треугольник справа от знака "`!`", чтобы настроить его.

|Tag
a|Зеленый/красный фон показывает загрузку ЦП в % (красный -- ядро, зеленый -- Firebird).

В тексте отображается значение тега (если оно было указано в SQL-запросе).

Пример установки значений тегов:

[listing]
----
SELECT * FROM RDB$DATABASE
/*FBSCANNER$CON_NAME=MyConnect;
FBSCANNER$TR_NAME=MyTransaction;
FBSCANNER$ST_NAME=SomeImportantQuery; */;
----

Также в этом столбце вы увидите выполнение инструментов `gbak` и `gfix`.

|Transaction Count
|Применимо для строки типа подключение.
Отображается количество активных транзакций в соединении.

Очень полезно найти приложения с автоматической фиксацией и другими неэффективными проблемами управления транзакциями.

|PID
|Идентификатор процесса Firebird. Только для архитектуры Classic.

|Client IP
|IP соединения

|Client Name
|DNS подключения (если возможно разрешить)

|Client Process Name
|Начиная с Firebird 2.1, `fbclient.dll` показывает имя клиентского приложения. Например, `C:\Program Files\Firebird\Firebird_2_1\bin\isql.exe`

|Priority
|Приоритет экземпляра Firebird (только Classic)

|Database
|Имя базы данных или ее псевдоним, как указано в строке подключения.

|User
|Имя пользователя -- например, SYSDBA (не поддерживается для Trusted Authentication)

|Role
|Роль пользователя

|Start
|Для строки соединения -- время соединения, для транзакции -- время начала транзакции, для оператора -- время начала запроса.

|Time
|`'NOW' - Start`; Время сначала старта

|Last Activity
|Время последнего действия для текущего соединения/транзакции/оператора.

|Inactive
|`'NOW' - Last Activity`; Период бездействия

|Latest Retaining
|Время последнего "`COMMIT RETAINING`" или "`ROLLBACK RETAINING`" в текущей транзакции.

|Retaining
|`'NOW' - Latest Retaining`

|Received
|Байты, полученные клиентом

|Sent
|Байты, отправленные клиентом

|CPU Time
|Показывает общее время, затраченное на соединение/транзакцию/запрос. Если в транзакциях более 1 запроса, время выполнения всех запросов будет суммироваться. То же правило применяется и для расчета времени соединения.

|Prepare Time
|

|Execute Time
|

|Fetch Count
|Применимо только для statements. Количество записей, как сообщает `fbclient.dll`

|Protocol
|Версия протокола Firebird для текущей сессии.

|Version
|Версия `fbclient.dll`/`gds32.dll`.

Определение версии не на 100 % верно: второстепенные версии считаются одинаковыми, JayBird и .NET Provider считаются одинаковыми, InterBase 8.x = InterBase 9.x
|===

В следующей таблице вы можете увидеть подробную информацию о значениях, отображаемых в первом столбце в строках FBScanner Viewer для SQL запросов:

[cols="1,1", options="header"]
|===
| Флаг
| Описание


|A
|Allocated. Начальная фаза жизненного цикла SQL-запроса

|P
|Prepared. Указывает, что запрос был подготовлен

|E
|Execute. В данный момент запрос выполняется

|C
|Closed statement. Выполнение завершено

|D
|Dropped statement.

|F
|Fetching is in progress

|f
|Fetching is in progress, но в данный момент приостановлено (набор записей не получен)

|c
|Closed cursor. Все данные были получены.
|===

==== Теги

Теги позволяют назначать читаемые идентификаторы (имена) соединениям, запросам и транзакциям.

Вам просто нужно добавить эти комментарии:

[listing]
----
SELECT COUNT(*) FROM RDB$DATABASE
/* FBSCANNER$CON_NAME=My_application;
   FBSCANNER$TR_NAME=Read_only_transaction_N1;
   FBSCANNER$ST_NAME=Customers_list_query; */
----

* FBSCANNER$CON_NAME= задает имя соединения. После первого назначения это имя будет сохраняться в течение всего срока действия соединения.
* FBSCANNER$TR_NAME= задает имя транзакции. После первого присвоения это имя будет использоваться в течение всего срока действия транзакции.
* FBSCANNER$ST_NAME= задает имя запроса.

Теги отображаются в первом столбце таблицы FBScanner Viewer, и теги можно фильтровать по их именам.

Теги полезны для быстрого ответа на следующие частые вопросы:

* Какая программа запустила этот запрос? (разработчикам необходимо пометить тегом FBSCANNER$CON_NAME каждое подключение к базе данных)
* Какова транзакция для этого запроса? (разработчикам необходимо использовать тег FBSCANNER$TR_NAME для обозначения транзакций)
* Что это за очень длительный запрос? (разработчик может помечать длительные запросы читаемыми именами, например "`Annual report`").

==== Меню FBScanner Viewer

FBScanner Viewer предлагает широкий спектр опций, упрощающих отладку и оптимизацию, которые доступны через его меню:

* *Сервер*
+
** Подключить...
** Отключить
** Последние сервера
** Выход
* *Подключения*
+
** Отключить
** Отключение клиентов...
** Завершить процесс...
** Последние запросы
** Старейшее подключение
** Приоритет процесса...
** Ping
** Ping всех
** Извлекать планы запросов
* *Транзакции*
+
** OAT
* *Инструменты*
+
** *Визуализация*
+
*** Администратор СУБД (только подключения)
*** Разработчик СУБД (без транзакций)
*** Разработчик СУБД (детально)
** Язык -- English, Italian, Русский, Portuguese
** Дополнения
** Настройки
* *Колонки* -- список столбцов
* *Помощь*


===== Сервер

Для подключения к службе FBScanner выберите menu:Сервер[Подключить...].

Появится следующий диалог:

image::4.3.22.png[]

После выбора сервера FBScanner Viewer запросит пароль. Существует 2 пароля -- для доступа только для чтения и для доступа администратора (полного). По умолчанию пароль для доступа только для чтения пуст.

image::4.3.23.png[]

[TIP]
====
Чтобы настроить пароли для доступа к FBScanner Viewer, вам необходимо перейти в "`FBScanner Configuration`" -- "`Advanced Settings`".
====

*Server\Disconnect* отключает FBScanner Viewer от службы FBScanner.

*Server\Recent Servers* показывает список последних служб FBScanner, к которым подключался FBScanner Viewer.

*Exit* закрывает FBScanner Viewer.

==== Connections

Пункты меню "`Disconnect`", "`Disconnect clients`" и "`Kill Process`" доступны только при подключении к службе FBScanner с правами администратора.

*Disconnect* предложит закрыть текущее соединение (выделено в основной таблицы FBScanner Viewer):

image::4.3.24.png[]

"`*Disconnect clients*`" запускает следующий диалог:

image::4.3.25.png[]

В правой части находится список подключений, представленный именами баз данных, клиентов или пользователей в соответствии с фильтром выше.

Используя кнопки &gt; и &lt;, администратор может выбрать соединения, которые нужно отключить, а затем нажать кнопку "`Disconnect`".

Отключение будет выполнено путем эмуляции ошибки 10054 -- соответствующие записи будут в `firebird.log` (`interbase.log`) и в `FBScanner.log`.

==== Kill

Есть несколько случаев, когда вам нужно завершить процесс Firebird, но мы не рекомендуем это делать.

"`Kill process...`" запрашивает явное завершение процесса Firebird и работает только на локальном FBScanner и с архитектурой Classic:

image::4.3.26.png[]

Он не будет работать с архитектурами SuperServer и SuperClassic.

"`*Latest Queries*`" показывает список из 20 последних запросов в выбранном соединении:

image::4.3.27.png[]

Это полезно для специальной отладки, работает как кнопка "`Rewind`".

[TIP]
====
Для полноценной регистрации SQL-трафика включите функцию регистрации SQL в службе FBScanner и используйте FBScanner LogAnalyzer для просмотра журнала.
====

"`*Oldest Connection*`" -- показывает самое старое соединение в таблице.

"`*Process Priority*`" -- применим только для локальной установки FBScanner с классической архитектурой.
Это позволяет установить приоритет процесса для экземпляров Classic.

"`*Ping Client*`" -- позволяет проверить -- активно ли выбранное соединение?

"`*Ping All Clients*`" -- проверяет все соединения тем же способом.

"`*Extract plans*`" запускает извлечение планов для выбранного подключения. Извлеченные планы отображаются в таблице, а также сохраняются в журнале SQL (или текстовом журнале).
Если ведение журнала не включено, ничего не происходит. Чтобы включить извлечение плана для всех подключений, используйте соответствующий параметр в "`FBScanner Configuration`".

==== Transactions

The single option *Transactions\OAT* will put selection in the grid to the oldest active transaction.

==== Tools

В меню "`Tools`" мы видим несколько опций.

With "`*View Style*`" user can select the most suitable representation of grid data:

* Database Administrator (connections only)
* Database Developer (without transactions)
* Database Developer (with transactions)

FBScanner Viewer is localized in 4 languages.

Use *Tools\Language* to switch between languages:

image::4.3.28.png[]

"`*Plugins*`" option enables plugins.

For more information please contact link:mailto:support@ib-aid.com[support@ib-aid.com]

"`*Options*`" is another way to change some of FBScanner Service parameters.

image::4.3.29.png[]

Please consider appropriate session of this guide for details of FBScanner Service Configuration.

==== SQL log structure

FBScanner stores SQL traffic in the following table:

[source,sql]
----
CREATE TABLE FBSCANNER$LOG
(
    ID                   BIGINT NOT NULL,
    IDATTACHMENT         BIGINT,
    IDTRANSACTION        BIGINT,
    PID                  INTEGER,
    ROW_TYPE             INTEGER NOT NULL,
    CLIENT_IP            VARCHAR(24),
    CLIENT_NAME          VARCHAR(256),
    CUSTOM_NAME          VARCHAR(256),
    SUBNET_NAME          VARCHAR(256),
    DB_FILENAME          VARCHAR(512),
    DB_USER              VARCHAR(512),
    DB_ROLE              VARCHAR(512),
    START_TIME           TIMESTAMP DEFAULT 'NOW' NOT NULL,
    END_TIME             TIMESTAMP,
    LAST_ACTIVITY        TIMESTAMP DEFAULT 'NOW' NOT NULL,
    LAST_RETAINING       TIMESTAMP,
    WORK_TIME            INTEGER DEFAULT 0 NOT NULL,
    CPU_TIME_USER        INTEGER DEFAULT 0 NOT NULL,
    CPU_TIME_PRIVILEGED  INTEGER DEFAULT 0 NOT NULL,
    FETCH_COUNT          INTEGER DEFAULT 0 NOT NULL,
    RESULT               INTEGER,
    SQL_TEXT             BLOB SUB_TYPE 1 SEGMENT SIZE 80,
    SQL_TEXT2            BLOB SUB_TYPE 1 SEGMENT SIZE 80,
    SQL_PLAN             BLOB SUB_TYPE 1 SEGMENT SIZE 80,
    PREPARE_TIME         INTEGER DEFAULT 0 NOT NULL,
    EXECUTE_TIME         INTEGER DEFAULT 0 NOT NULL
);
----

==== Logical structure

There are 3 levels of hierarchy in this table:

* ID -- primary key
* IDATTACHMENT and IDTRANSACTION -- foreign keys referenced to FBSCANNER$LOG.ID
* ROW_TYPE -- hierarchy level (0, 1, 2 )

.Level 1. Connection.ROW_TYPE = 0
[cols="1,1", frame="all"]
|===
|PID
|Process ID (only for local FBScanner)

|ROW_TYPE
|0

|CLIENT_IP
|IP address of client

|CLIENT_NAME
|DNS name

|CUSTOM_NAME
|Connection tag (if assigned in query text)

|SUBNET_NAME
|Logical name of subnet. See file `FBScanner.subnets`

|DB_FILENAME
|Database alias or full database path

|DB_USER
|User name

|DB_ROLE
|User role

|START_TIME
|Start of connection

|END_TIME
|End of connection
|===


.Level 2. Connection.ROW_TYPE = 1
[cols="1,1", frame="all"]
|===
|IDATTACHMENT
|Connection ID

|ROW_TYPE
|1

|CUSTOM_NAME
|Transaction tag (if assigned)

|START_TIME
|Transaction start time

|END_TIME
|Transaction end time

|LAST_RETAINING
|Time of most recent commit retaining or rollback retaining

|RESULT
|

0 – transaction is active

1 – Commit

2 – Rollback

|SQL_TEXT
|Transaction flags
|===



.Level 2. Connection.ROW_TYPE = 2
[cols="1,1", frame="all"]
|===
|IDATTACHMENT
|Connection ID

|IDTRANSACTION
|Transaction ID

|ROW_TYPE
|2

|CUSTOM_NAME
|Query tag (if assigned)

|START_TIME
|Query start time

|WORK_TIME
|Time till the answer from server

|CPU_TIME_USER
|CPU Time (local only)

|CPU_TIME_PRIVILEGED
|CPU Kernel Time (local only)

|FETCH_COUNT
|Number of records, returned by query

|RESULT
|0 -- query executed successfully, otherwise this field contains SQLCODE of error

|SQL_TEXT
|Query text (with parameters)

|SQL_TEXT2
|Original query text(NULL if equal to SQL_TEXT)

|SQL_PLAN
|Query execution plan (if "`Extract plans`" setting is enabled)

|**PREPARE_TIME**
|Prepare time

|**EXECUTE_TIME**
|Query execution time
|===

==== Indices in the log

Initially log database contains only primary key index.

FBScanner Log Analyzer creates necessary indices at the first connect.

=== FBScanner Feature Matrix

[cols="1,4,1,1"]
|===
.2+h| #
.2+h| Feature
2+h|FBScanner mode

h| Agent
h| Remote


|
|Operation Systems Support
|
|

|
|**Windows**
|X
|X

|
|Linux, Mac OS X, Free BSD
|
|X

|
|Firebird and InterBase versions supported
|
|

|
|Firebird 1.0, Yaffil 1.0 (including logging)
|X
|X

|
|Firebird 1.5 (including logging)
|X
|X

|
|Firebird 2.0 (including logging)
|X
|X

|
|Firebird 2.1 (including logging)
|X
|X

|
|Firebird 2.5 (including logging + SuperClassic support)
|X
|X

|
|InterBase 6.0-2009/XE (including logging)
|X
|X

|**1**
|**Connections**
|
|

|**__1.1__**
|**__Information about established connections in the FBScanner Viewer:__**
|
|

|
|Firebird/InterBase user login
|X
|X

|
|IP-address or computer name
|X
|X

|
|Connection time and time of the latest activity
|X
|X

|
|Priority of processes (only for Classic architecture)
|X
|

|**__1.2__**
|**__Connection management (requires logging to FBScanner Viewer with Admin rights)__**
|
|

|
|Safe disconnect of one or several connections using TCP/IP connection interruption (imitation of 10054 error)
|X
|X

|
|Changing of processes priority in Classic architecture (for example, to adjust priority of long running report or something like this. Using tags administrator can recognize connection where report is working -- see below in "`Tags`").
|X
|

|
|Automatic priority settings for Firebird with Classic architecture.
In FBScanner configuration administrator can set up automatic correspondence:

Specified IP or subnet of IPs – set priority X

Specified hostname – set priority X

Specified database name – set priority X

Specified user login name – set priority X
|X
|

|
|Killing of Classic processes, not recommended to use, but sometimes it is helpful
|X
|

|
|Ability to restrict all connections (to perform some operations which require exclusive access)
|X
|X

|
|Filtering connections viewing using all connections parameters (except time information)
|X
|X

|
|White and black list of databases to connect
|X
|X

|
|White and black list of IP addresses (clients)
|X
|X

|
|Restriction of connections # -- administrator can limit the number of connections
|X
|X

|
|Emulation of "`Wrong login/password`" error for denied connections
|X
|

|
|Detection of old/incorrect versions of fbclient.dll/gds32.dll
|X
|X

|**__1.3__**
|**__Logging events related with connections__**
|X
|X

|
|FBScanner logs unsuccessful login attempts in the `FBScanner.log`. For each unsuccessful login attempt FBScanner writes the following information: IP-address, login name, database and time of login attempt.
|X
|X

|
|

If connection was broken (10054 error), FBScanner determines and logs one of the 5 type of disconnects:

Client application was closed improperly (for instance, application was closed by Task Manager)

Connection was closed by time-out (it's possible to set forced disconnect in FBScanner to close connect by time-out too)

Server crashed (fbserver or fb_inet_server crashed)

Server process (fbserver or fb_inet_server) was killed from the FBScanner

Disconnect of connections from FBScanner Viewer

For all cases above FBScanner writes the IP-address of disconnected client(s) and the reason of disconnect.
This is very useful feature to find and eliminate 10054 errors.
|X
|X


|**2.**
|**Transactions**
|
|

|**__2.1.__**
|**__Transactions are shown inside appropriate connections__**
|
|

|
|Transactions' flags
|X
|X

|
|Lifetime of transactions
|X
|X

|
|Using OAT button you can find the oldest active transaction in real-time and review related connection/queries.
|X
|X

|**3.**
|**Queries (statements)**
|
|

|**__3.1__**
|**__Information about queries(statements)__**
|
|

|
|Start time
|X
|X

|
|Query text
|X
|X

|
|Transaction of the query
|X
|X

|
|Status (prepare/execute/...)
|X
|X

|
|Filtering by statement status (by default Closed statements are hidden)
|X
|X

|
|Instant CPU load indicator
|X
|X

|
|If query PREPARE or execution caused error, FBScanner writes SQLCODE to the log (for example, primary key violation)
|
|

|**__3.2__**
|**__Additional operations with queries__**
|
|

|
|

Ad-hoc plan extraction for queries

Can be performed for all connections (should be set ON in FBScanner configuration utility)

Can be turned ON/OFF for selected connection only in the FBScanner Viewer

In both cases plans will be logged to the overall log if logging is ON.
|X
|X

|**4.**
|**Tags**
|
|

|
a|Tags allow assigning readable identifiers (names) to Connections, Queries and Transactions. You just need to add these commentaries:

[source]
----
SELECT COUNT(*) FROM RDB$DATABASE
/* FBSCANNER$CON_NAME=My_application;
FBSCANNER$TR_NAME=Read_only_transaction_N1;
FBSCANNER$ST_NAME=Customers_list_query; */
----

|X
|X

|
|FBSCANNER$CON_NAME= sets the name of connection. After the first assignment this name will be kept during the whole connection life.
|X
|X

|
|FBSCANNER$TR_NAME= sets the name of transaction. After the first assignment this name will be used during the whole life of transaction
|X
|X

|
|FBSCANNER$ST_NAME= sets the name of query.
|
|

|
|Tags are showed in special column in FBScanner Viewer
|X
|X

|
|It's possible to filter tags by their names
|X
|X

|
|

Tags are useful to quickly answer the following frequent questions:

What program has launched this query? (developers need to mark with FBSCANNER$CON_NAME tag each database connection)

What is the transaction for this query? (developers need to use FBSCANNER$TR_NAME tag to mark transactions)

What is this very long query? (developer can mark long queries with readable names like "`Annual report`")
|X
|X

|**5.**
|**Logging**
|
|

|
|Logging allows intercepting all queries and writing them to the external Firebird database. FYI, logging cannot be replaced with Firebird 2.1 or InterBase system tables, because they provide only snapshots of programs.
|X
|X

|
|Connections, queries and transactions are logged
|X
|X

|
|All executed queries are logged (only prepared quires skipped)
|X
|X

|
|Queries are stored with information about their connection and transaction
|X
|X

|
|All transactions are logged, even rolled back. Transaction log record has column RESULT which shows was transaction committed or rolled back.
|X
|X

|
|If plan extraction is on, queries plans are logged too
|X
|X

|
|Automatic creation of database for logging
|X
|X

|
|Automatic creation of tables to logging in any Firebird database
|X
|X
|===
