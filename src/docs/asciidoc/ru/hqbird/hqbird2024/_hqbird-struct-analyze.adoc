[[hqbird-struct-analyze]]
= Анализ структуры базы данных

== Обзор структуры базы данных Firebird

Первое, что следует сказать о структуре базы данных Firebird, это то, что она представляет собой набор страниц строго определенного размера: 4096, 8192, 16384 или 32768 (начиная с Firebird 4.0).

Страницы могут быть разных типов, каждая из которых служит определенной цели.

Страницы одного типа не идут строго одна за другой -- они могут быть перемешаны, и размещены в файле в том порядке, в котором они были созданы сервером при расширении или создании базы данных.

image::5.1.1.png[]

.Типы страниц
[cols="2,1,3", options="header"]
|===
| Тип страницы
| ID
| Описание

|**pag_undefined**
|0
|Undefined -- Если страница имеет этот тип страницы, скорее всего, она пуста.

|**pag_header**
|1
|Database header page

|**pag_pages**
|2
|Page inventory page (or Space inventory page -- SIP)

|**pag_transactions**
|3
|Transaction inventory page (TIP)

|**pag_pointer**
|4
|Pointer page

|**pag_data**
|5
|Data page

|**pag_root**
|6
|Index root page

|**pag_index**
|7
|Index (B-tree) page

|**pag_blob**
|8
|Blob data page

|**pag_ids**
|9
|Gen-ids

|**pag_log**
|10
|Write ahead log information
|===

<<<

== Как анализировать структуру базы данных с помощью HQbird Database Analyst (IBAnalyst)

*IBAnalyst* — это инструмент, который помогает пользователю детально анализировать статистику базы данных Firebird и выявлять возможные проблемы с производительностью базы данных, ее обслуживанием и взаимодействием приложения с базой данных.

IBAnalyst графически отображает статистику базы данных Firebird в удобной для пользователя форме и выявляет следующие проблемы:

* фрагментирование таблиц и BLOB,
* версии записей,
* сборка мусора,
* эффективность индексов

Более того, IBAnalyst может автоматически вносить разумные предложения по улучшению производительности и обслуживанию базы данных.

IBAnalyst может получать статистику из действующих производственных баз данных через Services API (рекомендуется) или анализировать текстовый вывод команд `gstat -a -r`.
Статистика в периоды пиковой нагрузки может дать много информации о реальных проблемах с производительностью в производственных базах данных.

Основные возможности IBAnalyst перечислены ниже:

* Получение статистики базы данных через Service API и из вывода `gstat`.
* Сводка всех актуальных и возможных проблем в базе данных
* Цветная сетка для представления таблиц, индексов и таблиц->индексов, которая выделяет фрагментированные таблицы, плохие индексы и т. д.
* Автоматическая экспертиза статистики базы данных предоставляет рекомендации и инструкции по следующим вопросам:
** Оптимальный размер страницы базы данных
** Состояние транзакций и критический разрыв между транзакциями.
** Различные флаги базы данных
** Глубина индекса
** Дубликаты ключей индекса
** Фрагментированные таблицы
** Версии записи
** Очень большие таблицы
* и другое

=== Как правильно получать статистику из базы данных Firebird

==== Правильное время и место

Звучит странно, но просто взять статистику через gstat или Services API недостаточно. Статистику необходимо собирать в нужный момент, чтобы показать, как приложения влияют на данные и транзакции в базе данных.

Худшее время для сбора статистики

* Сразу после восстановления
* После снятия резервной копии (`gbak -b db.gdb`) без указания переключателя `-g`
* После ручного sweep (`gfix -sweep`)

Также верно, что во время работы могут быть моменты, когда база данных находится в правильном состоянии, например, когда приложения нагружают базу данных меньше, чем обычно (пользователи обедают, ужинают или в определенное время бизнес-процесса).

Как обнаружить, что в базе данных что-то не так?

Да, ваши приложения могут быть спроектированы настолько идеально, что они всегда будут корректно работать с транзакциями и данными, не создавая sweep gap, большого количества активных транзакций, длительных снимков и так далее. Обычно этого не происходит. Хотя бы потому, что некоторые разработчики тестируют свои приложения под управлением 2-3 пользователей одновременно, не более. Таким образом, при настройке написанных приложений для 15 и более одновременных пользователей база данных может вести себя непредсказуемо. Конечно, многопользовательский режим может работать нормально, поскольку большинство многопользовательских конфликтов можно протестировать с помощью 2-3 одновременно работающих приложений. Но затем, когда будет запускаться больше одновременно работающих приложений, могут возникнуть проблемы со сборкой мусора (по крайней мере). И это можно поймать, если в правильные моменты снимать статистику.

==== Если у вас не возникают периодические проблемы с производительностью

Это может произойти, если ваши приложения спроектированы правильно, база данных не загружена или ваше оборудование современное и очень мощное (достаточно для хорошей обработки текущего количества пользователей и данных).

Самая ценная информация -- это транзакционная нагрузка и накопление версий. Это можно увидеть, только если настроить регулярное сохранение статистики.

Лучшая настройка -- получать почасовую статистику транзакций. Это можно сделать, запустив

[source,bash]
----
gstat -h db.gdb > db_stat_<time>.txt
----

где

* `db.gdb` -- имя вашей базы данных,
* `db_stat_<time>.txt` -- текстовый файл, в котором будет сохраняться статистика,
* `<time>` -- текущая дата и время, когда была снята статистика.

Также вы можете запланировать сбор статистики базы данных с помощью HQbird FBDataGuard, задание "`Database: Statistics`".

==== Если у вас периодически возникают проблемы с производительностью

Эти проблемы обычно вызваны автоматическим запуском sweep. Сначала вам нужно определить период времени между такими падениями производительности. Далее разделите этот интервал минимум на 4 (8, 16 и так далее). Сейчас в информационных системах много одновременно работающих пользователей, и большинство проблем с производительностью при ненастроенных сервере и базе данных происходят по 2 или 3 раза в день.

Например, если проблемы с производительностью возникают каждые 3 часа, вам необходимо собирать

[source,bash]
----
gstat -h db.gdb
----

статистику каждые 30-45 минут, и

[source,bash]
----
gstat -a -r db.gdb -user SYSDBA -pass masterkey
----

каждые 1-1.5 часа.

Лучше всего, когда вы соберёте статистику `gstat -a -r` прямо перед предстоящим падением производительности. Она покажет, где настоящий мусор и сколько скопилось устаревших версий записей.

==== Что делать с этой статистикой?

Если ваше приложение явно использует транзакции и использует их хорошо, т. е. вы знаете, что такое `read read_commit` и когда его использовать, ваши SNAPSHOT транзакции длятся не дольше, чем необходимо, и транзакции активны минимальный период времени, вы можете настроить sweep interval, или отключить его, а затем заботьтесь только о том, сколько обновлений делает приложение(я) и какие таблицы нужно меньше обновлять или заботиться об обновлениях.

Что это значит, спросите вы? Приведем пример некоторой системы, в которой каждое утро в течение 20-30 минут возникали проблемы с производительностью. Этого вполне обычно для "`утренних`" запусков приложений, и дольше оно не может продолжаться.

Администратору базы данных задали правильные вопросы, и вот картина:

Ежедневная работа была разделена на части: утром анализ данных, затем данные вставляются и редактируются обычными операторами, а в конце дня специальные процедуры начинают сбор данных, которые будут использоваться для аналитики на следующий день (как минимум).

Последняя работа над базой данных в конце дня заключалась в большом количестве обновлений, причем обновлений тех таблиц, которые аналитики использовали утром. Итак, появилось много мусорных версий, которые начало собирать приложение, работающее с утра.

Решение это проблемы оказалось простым -- запускать `gfix -sweep` в конце дня.

Sweep читает все таблицы в базе данных и пытается собрать в них все мусорные версии для зафиксированных и откаченных транзакций. После очистки базы данных стало ясно, почему улучшение происходит после восстановления.

И "`утренняя проблема`" ушла.

Итак, вам нужно понимать статистику с учетом множества других факторов:

* сколько одновременно пользователей (в среднем) работает в течение дня
* продолжительность рабочего дня (8, 12, 16, 24 часа)
* какие приложения работают в разное время суток и как они влияют на данные, используемые другими приложениями, работающими в то же время или в последующее время. Т.е. вы должны понимать бизнес-процессы, происходящие в течение всего дня и всей недели.


==== Когда DBA не может ничего сделать

К сожалению, такие ситуации случаются. И снова пример:

Некоторая система установлена примерно для 15 пользователей. Периодически производительность настолько падает, что администратору базы данных приходится перезагружать сервер. После перезагрузки сервера какое-то время все работает нормально, затем производительность снова падает. Статистика показала, что среднее количество транзакций в день составляет около 75000, и есть активные транзакции, выполняемые с начала дня до момента падения производительности.

К сожалению, приложения были написаны с использованием BDE и вообще без использования транзакций; то есть вся обработка транзакций была автоматической и использовалась самим BDE. Из-за этого некоторые транзакции оставались активными в течение длительного времени, а мусор (версии записей) накапливался до тех пор, пока администратор базы данных не перезапустил сервер. После перезапуска начнется автоматическая очистка, и мусор будет собран (устранен).

Все это было вызвано приложениями, потому что они тестировались только с 2-3 одновременными пользователями, а когда их стало ~15, приложения начали очень сильно нагружаться.

Надо сказать, что в этой конфигурации 70% пользователей только читали данные, а остальные 30% вставляли и обновляли какие-то (!) данные.

В этой ситуации единственное, что может улучшить производительность, — это перепроектировать управление транзакциями в этом приложении.

==== Как IBAnalyst может помочь найти проблемы в вашей базе данных Firebird

Давайте рассмотрим ключевые возможности IBAnalyst. Когда вы впервые просматриваете статистику своей базы данных в IBAnalyst, все может быть неясно, особенно если IBAnalyst показывает множество предупреждений в виде окрашенных в красный и желтый цвет ячеек в представлениях Summary, Tables и Index. Рассмотрим несколько примеров из реальной статистики.

=== Закладка Summary

Summary содержит наиболее важную информацию, извлеченную из статистики базы данных. Обычно полная статистика базы данных содержит сотни Кбайт и распознать важную информацию непросто.

Ниже приведено описание объектов и параметров базы данных, которые вы можете увидеть в разделе Summary. Описание видимых проблем (отмеченных *красным* или **желтым**) смотри в подсказках для столбцов или выводе рекомендаций.

[cols="1,2", options="header"]
|===
| Объект или параметр
| Описание

|**Database name**
|Имя анализируемой базы данных.

|**Creation date**
|Дата создания базы данных. Когда она был создан оператором `CREATE DATABASE` или восстановлена (`gbak -c` или `gbak -r`).

|**Statistics date**
|Когда была получена статистика -- дата файла статистики или дата вызова service API (сейчас).

|**Page size**
|Размер страницы -- это физический параметр базы данных. В современных версиях Firebird размер страницы может быть 4096, 8192 или 16384 байта (Firebird __4.0+ может использовать размер страницы 32 КБ__). Для повышения производительности восстановите базу данных из резервной копии, используя размер страницы 8 или 16 КБ. 

|**Forced Write**
|Показывает режим записи измененных страниц: синхронизированный или асинхронный -- соответствующая настройка ON или OFF. OFF не рекомендуется, так как сбой сервера, сбой питания или другие проблемы могут привести к повреждению базы данных.

|**Dialect**
|Текущий диалект базы данных.

|**Sweep interval**
|Текущее значение sweep interval. Отмечено желтым, если оно не равно 0, и отмечено красным, если sweep gap больше sweep interval.

|**On Disk Structure**
|ODS. Это физический формат базы данных. Смотри подсказку, чтобы узнать номер ODS для конкретных версий IB/FB.

2+|**Transaction block**

|**Oldest transaction**
|Oldest interesting transaction.
Идентификатор старейшей транзакции которая откачена или находится в состоянии limbo.

|**Oldest snapshot**
|Oldest snapshot transaction
Идентификатор транзакции, которая была самой старой активной на момент запуска самого старого моментального снимка (snapshot).

|**Oldest active**
|Oldest active transaction
Идентификатор самой старой все еще активной транзакции.

|**Next transaction**
|Идентификатор следующей транзакции.

|**Sweep gap (snapshot - oldest)**
|Для ODS 10.x. Разница между Oldest Snapshot и Oldest Interesting transaction. Если она больше sweep interval и sweep interval > 0, то Firebird попытается запустить sweep, и это может замедлить производительность.

|**Snapshot gap (active - oldest)**
|Разница между Oldest Active и Oldest transaction. То же самое что и sweep gap.

|**TIP size**
|Размер Transaction Inventory Pages, в страницах и килобайтах. TIP сохраняет состояние транзакции для каждой транзакции, запущенной с момента создания (или восстановления) базы данных. Он рассчитывается как Next transaction div 4 (байты).

|**Snapshot TIP Size**
|Размер Transaction Inventory Pages необходимых для snapshot транзакций. Отображает сколько памяти потребуется каждой snapshot транзакции для проверки состояния параллельных транзакций.

|**Active transactions**
|Количество активных транзакций (на момент взятия статистики из базы данных) `Next - Oldest Active`. Это неточная оценка, потому что может быть одна активная транзакция и множества завершённых после неё. В любом случае активные транзакции предотвращают сборку мусора.

|**Transactions per day**
|Просто делит Next transaction на количество дней между датой создания базы данных и датой сбора статистики. Показывает среднее количество транзакций в день. Это значение бесполезно, если это не рабочая база данных. Предупреждения о транзакциях в основном основаны на среднем количестве транзакций за день.

|**Data versions percent**
|Процент версий записей в базе данных. Также отображается общий размер записей и размер версий для всех таблиц, а также общий размер индексов. Строка не отображается, если статистика не содержит информации о количестве записей (`gstat -a` без опции `-r`). Обратите внимание, что в вашей базе данных может быть много других данных (transaction inventory pages, empty pages и т. д.).

2+|**Table/Index lists **(также отображается в рекомендациях)

|**Fragmented Tables**
|Здесь вы можете просмотреть таблицы (с данными > 200 килобайт), средняя заполненность которых составляет менее 60 % (File/Options/Table average fill).

|**Versioned Tables**
|Список таблиц Versions которых больше чем Records, установленной в Options/Tables.

|**Tables fragmented with blobs**
|Список таблиц, в которых есть поля BLOB с размером данных меньше размера страницы базы данных.

|**Massive deletes/updates**
|Список таблиц, в которых большое количество данных было удалено/обновлено одним оператором delete/update.

|**Very big tables**
|Таблицы, близкие к техническому лимиту InterBase (36 гигабайт на таблицу). Вы увидите предупреждение, прежде чем может возникнуть проблема.

|**Deep Indices**
|Индексы с глубиной больше 3 (Options/Index)

|**Bad Indices**
|Индексы с большими значениями MaxDup и TotalDup

|**Broken or incomplete indices**
|Индексы с количеством ключей меньше количества записей. Это может произойти, когда индекс сломан или когда статистика собирается во время создания или повторной активации индекса.

|**Useless Indices**
|Индексы с уникальным количество ключей = 1. Могут быть удалены или деактивированы, поскольку они бесполезны для операций поиска по индексу или сортировки.

|**Tables with no records**
|Список таблиц с Records = 0. Это может быть задумано (временные таблицы), а может быть просто забыто разработчиком базы данных.
|===

image::5.2.1.png[]


На странице сводки отображается много информации, но наиболее ценным является состояние транзакций (__пожалуйста, прочтите описание возможных состояний транзакций в справке IBAnalyst, его можно получить, нажав F1 или в меню Help__).

На этом скриншоте вы можете видеть, что какая-то транзакция активна в течение длительного времени, "`60% of daily average`". IBAnalyst помечает состояние такой транзакции красным, поскольку эта транзакция может помешать серверу рассматривать накопленные версии как мусор и, следовательно, собирать мусор. Это возможная причина замедления: чем больше версий существует для некоторой записи, тем больше времени потребуется на ее чтение.

Чтобы найти эту длительную транзакцию, вы можете использовать `MON$Logger` или выполнить прямой запрос к таблицам `MON$`. Затем, чтобы узнать, на какие таблицы повлияли длительные транзакции (таблицы с большим количеством версий записей), вам нужно перейти на закладку "`Tables`" в IBAnalyst.

=== Закладка Tables

Закладка *Таблицы* содержит информацию обо всех таблицах базы данных. Она предоставляет важную статистическую информацию о каждой таблице. Все таблицы с предупреждениями отмечаются (подробности см. ниже).

Вы можете увидеть следующие столбцы (столбцы *Records, RecLength, VerLen, Versions, Max Vers* видны только в том случае, если статистика была сгенерирована с помощью `gstat -r` или с установленным флажком "`Include record/rec versions`"):

[cols="1,2", options="header"]
|===
| Столбец
| Описание

|**Records**
|Количество записей. Помечено розовым, если таблица фрагментирована полями BLOB, данные в которых меньше размера страницы базы данных. Подсказка показывает реальную фрагментацию таблицы и среднее количество записей, как если бы полей BLOB не было. Такая фрагментация может привести к снижению производительности при соединении больших таблиц или полном сканировании.

|**RecLength**
|Средняя длина записи. Зависит от данных записи, особенно от данных столбцов типов char/varchar. Минимальная физическая длина записи -- 17 байт (заголовок записи + все поля равны `NULL`), максимальная -- как указано в таблице. Статистика показывает эти данные без подсчета заголовков записей, в этом случае RecLength может быть равен 0 (если удалены почти все записи).

|**VerLen**
|Средняя длина версии записи. Если оно близко к RecLength, обновляются почти все записи. Если VerLen составляет 40-80% и не превышает RecLength, то версии в основном представляют собой обновления. Если VerLen превышает 80-90% от RecLength, то возможно, версии в основном удаляются или обновляются столбцы char/varchar с новыми, более крупными данными. Отмечено *желтым*, если его размер превышает указанный процент (Options/Record/Version size) от среднего размера записи.

|**Versions**
|Текущее количество версий записи. Чем больше версий тем медленней читается таблица. Также большое количество версий означает, что сборка мусора не выполняется или записи никем не читаются. Отмечено *красным*, если количество версий превышает количество записей (Options/Record Versions).

|**Max Vers**
|Максимальное количество версий записи для одной конкретной записи. Отмечено *синим*, если оно равно 1, а значение Versions не равно нулю. Это означает, что произошла массовая операция обновления/удаления. Смотри Options, Table, Massive deletes updates option.

|**Data Pages**
|Выделено страниц данных

|**Size, Mb**
|`DataPages * Page Size`, в мегабайтах. То есть это общий размер таблицы, records + versions. График показывает процент этой таблицы от общего объема данных.

|**Idx Size, Mb**
|Сумма всех размеров индексов для этой таблицы. График показывает процент этого значения от общего размера всех индексов.

|**Slots**
|Количество ссылок на страницы данных. Пустые ссылки -- это Slots-Data Pages. Не влияет на дисковое пространство и производительность.

|**Average Fill**
|Средний процент заполнения страницы данных. Может быть вычислен как `(DataPages * Page_Size)/ Records * RecLength`. Низкая заполнение страницы означает, что таблица "`фрагментирована`". Частые обновления/удаления могут фрагментировать страницы данных. Отмечено *красным*, если средний коэффициент заполнения менее 60% (чтобы изменить это зайдите в Options/Average Fill). Отмечается *желтым*, если это артефакт высокой фрагментации таблицы, когда ее запись слишком мала (11-13 байт).

|**Real Fill**
|Поскольку мы обнаружили, что среднее заполнение, рассчитанное с помощью `gstat`, иногда дает неправильные результаты (по крайней мере, для таблиц с небольшими BLOB), мы разместили здесь вычисляемый столбец, который считает среднее заполнение не по страницам данных, а по записям + версиям, включая заголовок записи.

|**20%, 40%, 60% and 100% fill**
|Показывает количество страниц с соответствующим коэффициентом заполнения. Можно включить/выключить в диалоговом окне Options.

|**Total %**
|Насколько велика эта таблица плюс ее индексы в % по отношению к другим таблицам.
|===

image::5.2.2.png[]

На закладке "`Tables`" вы можете увидеть таблицы и их важные параметры: количество записей, количество версий записей, длину записи, максимальное количество версий и т. д.

Вы можете отсортировать эту таблицу, чтобы найти самые большие таблицы. Особенно нас интересуют таблицы с большим количеством версий записей -- большое количество версий записей замедлят сборку мусора для затронутых таблиц. Обычно необходимо изменить алгоритмы обновления и удаления, чтобы избавиться от множества версий записей.

Столбец Versions показывает общее количество версий для конкретной таблицы, а столбец Max Vers показывает максимальное количество версий, достигнутых некоторой записью. Например, если вы посмотрите на таблицу `SITE`, то в ней 40611 записей, а общее количество версий -- 76142, но одна запись имеет 501 версию. Чтение и анализ такой цепочки версий с диска занимает больше времени, поэтому чтение этой записи происходит медленнее, чем чтение других.

На этом изображении также показано множество таблиц, данные из которых были удалены. Но из-за длительной транзакции сервер не может удалить эти версии, и они все еще находятся на диске, все еще индексируются и все еще читаются сервером при чтении данных.

=== Закладка Indices

Закладка *Indices* отображает все индексы в вашей базе данных. Оценить эффективность индексов можно по следующим параметрам (проблемные индексы отмечены *красным* — подробности смотри в умных подсказках)

[cols="1,2", options="header"]
|===
| Столбец
| Описание

|**Depth**
|Глубина индекса -- это количество страниц, которые движок считывает с диска для перехода от корня индекса к указателю на записи. Оптимальная глубина индекса составляет 3 или меньше. Если глубина равна 4 и выше, рекомендуется увеличить размер страницы базы данных (создать резервную копию, а затем восстановить с использованием опции `-page_size`). Этот столбец будет отмечен красным, если глубина индекса превышает 3 (Options/Index/Index Depth). Наибольший шанс превысить оптимальную глубину имеют индексы, построенные на столбцах с длинными char/varchar.

|**Keys**
|Количество ключей индекса. Обычно равно Records. Если Keys больше чем Records и Versions больше 0, то это означает, что значение конкретного поля было изменено в этих версиях записи. Если Table.RecVersions больше чем Keys, то эти поля индекса не изменяются во время обновлений.

|**KeyLen**
|Средняя длина индексного ключа. Чем меньше KeyLen, тем больше равных или похожих (постфиксных) значений (ключей) хранится в индексе.

|**Max Dup**
|Максимальное количество дубликатов для определенного значения ключа. Отмечено *красным*, если количество дубликатов составляет 30 % от всех ключей. (Options/Index/Lot of key duplicates).

|**Total Dup**
|Общее количество ключей с одинаковыми значениями.

Чем ближе это значение к Keys count, , тем менее эффективным будет поиск по этому индексу, особенно если поиск выполняется с использованием более чем одного индекса.  Значение Total Dup можно подсчитать как количество ключей (Keys) минус количество уникальных ключей (Uniques) (статистика индекса нелинейна).

Отмечено *желтым*, если `1/(Keys - TotalDup)` больше чем 0.01, и *красным*, если в дополнение MaxDup тоже отмечен красным. Эта константа (0.01) используется оптимизатором (см. исходники в `opt.cpp`) в качестве полезной границы селективности индекса. Оптимизатор по-прежнему будет использовать этот индекс, если для какого-либо условия не существует другого индекса с лучшей избирательностью.

|**Uniques**
|Количество различных значений ключа. Индексы первичного и уникального ключа будут иметь то же значение, что и в столбце Keys. Полезно понимать, сколько разных значений хранится в индексе. Индекс бесполезен, если в столбце Unique указано 1 (отмечено желтым).

|**Selectivity**
|Информация из `rdb$indises.rdb$statistics`, видна только в том случае, если параметр "`load table/index metadata`" включен. Если селективность, сохраненная в базе данных, отличается от вычисленной селективности, отображается предупреждение *желтого* цвета (разница менее 20%) или *красного* (разница более 20%). *Синее* предупреждение отображается, когда индекс пуст, но его селективность не равна 0. Селективность неактивных индексов игнорируется.

|**Size, Mb**
|Размер индекса в мегабайтах. Gap показывает процент размера этого индекса по отношению к общему размеру всех индексов.

|**Average Fill**
|Средняя заполняемость индексных страниц, в %. Отмечено *красным*, если средняя скорость заполнения менее 50% (для настройки этого перейдите в  Options/Average Index Fill). Фрагментированный индекс приводит к большему количеству прочитанных страниц, и обычно его глубина (Depth) может быть выше. Это можно исправить, выполнив `alter index active`, если он не является индексом, созданным для ограничения первичного, уникального или внешнего ключа.

|**Leafs**
|Количество листовых страниц (страницы с ключами и указателями на записи).

|**20%, 40%, 60% and 100% fill**
|Показывает количество страниц с соответствующей коэффициентом заполнения. Можно включить/выключить в диалоговом окне Options.
|===

image::5.2.3.png[]

Некоторые производственные базы данных могут иметь индексы с индексированным единственным значением ключа. Это может произойти потому, что база данных была разработана "`с целью расширения в будущем`", или кто-то просто экспериментировал с индексами во время разработки или тестирования. Вы можете увидеть эти индексы как "`Useless`" в IBAnalyst: `I_NUMBER` и другие, построенные на столбце, который имеет только одно значение для всех записей. Эти индексы действительно бесполезны, потому что

* Оптимизатор может использовать этот индекс, если вы укажете "`where field =...`". Поскольку поле содержит только одно значение, использование индекса приведет к бесполезному чтению страниц индекса с диска в память и потребует памяти (и времени), когда сервер будет подготавливать записи для отображения для этого запроса.
* Создание индексов является частью процесса восстановления. Дополнительные индексы замедляют восстановление базы данных.

Конечно, это еще не все, что вы можете узнать о своей базе данных в IBAnalyst. Вы также можете найти

* среднее количество транзакций в день
* были ли откаты или потеря соединения и когда
* размер (в мегабайтах) каждой таблицы и индекса
* таблицы, в которых записи перемешаны с BLOB, из-за чего чтение только записей происходит медленнее
* пустые таблицы -- просто забыты или пусты на момент снятия статистики
* индексы с большим количеством повторяющихся ключей (нужно задуматься о распределении значений для столбца)
* индексы с глубиной 4 и выше -- возможно, вам нужно увеличить размер страницы для ускорения
